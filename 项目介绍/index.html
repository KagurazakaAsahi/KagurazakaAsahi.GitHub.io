<!-- build time:Thu Dec 12 2024 05:48:17 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="zh-CN"><head><link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/c/font_3880508_qdbn3887z5k.css"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="KA's Blog" href="https://kagurazakaasahi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="KA's Blog" href="https://kagurazakaasahi.github.io/atom.xml"><link rel="alternate" type="application/json" title="KA's Blog" href="https://kagurazakaasahi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=LogoSC%20LongZhuTi:300,300italic,400,400italic,700,700italic%7CMonaFang%20SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java,git,springcloud"><link rel="canonical" href="https://kagurazakaasahi.github.io/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"><title>项目介绍 - 学习 | 咖酱の博客 = KA's Blog = 等待,并心怀希望吧</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">项目介绍</h1><div class="meta"><span class="item" title="创建时间：2024-09-01 17:30:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-09-01T17:30:00+08:00">2024-09-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>23k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>21 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">咖酱の博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/f33e141ba4cf6090f0d2d2adf78822e5.png"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/417c1fcfe2da794b4074036d0bc5f027.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/bc573c5c75c59abe0cd3ec9b761b0ce5.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/82f21f8d9c564b3c56670825f878abbc.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/8d50767c448851d62f445bd854a82e57.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/03/08/5144eadcae3f3fe4806d754149cacb52.jpeg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/study/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kagurazakaasahi.github.io/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="KagurazakaAsahi"><meta itemprop="description" content="等待,并心怀希望吧, 欢迎来到咖酱的Blog~~🌸"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="KA's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="项目介绍"><a class="anchor" href="#项目介绍">#</a> 项目介绍</h1><h2 id="产品定位"><a class="anchor" href="#产品定位">#</a> 产品定位</h2><p>为餐饮企业定制的一款软件产品</p><h2 id="产品架构"><a class="anchor" href="#产品架构">#</a> 产品架构</h2><h3 id="管理端"><a class="anchor" href="#管理端">#</a> 管理端</h3><ul><li>员工管理</li><li>分类管理</li><li>菜品管理</li><li>套餐管理</li><li>订单管理</li><li>工作台</li><li>数据统计</li><li>来单提醒</li></ul><h3 id="用户端"><a class="anchor" href="#用户端">#</a> 用户端</h3><ul><li>微信登录</li><li>商品浏览</li><li>购物车</li><li>用户下单</li><li>微信支付</li><li>历史订单</li><li>地址管理</li><li>用户催单</li></ul><h2 id="技术选型"><a class="anchor" href="#技术选型">#</a> 技术选型</h2><h3 id="用户层"><a class="anchor" href="#用户层">#</a> 用户层</h3><ul><li>node.js</li><li>VUE.js</li><li>ElementUI</li><li>微信小程序</li><li>apache echarts</li></ul><h3 id="网关层"><a class="anchor" href="#网关层">#</a> 网关层</h3><ul><li>Nginx</li></ul><h3 id="应用层"><a class="anchor" href="#应用层">#</a> 应用层</h3><ul><li>Spring Boot</li><li>Spring MVC</li><li>Spring Task</li><li>httpclient</li><li>Spring Cache</li><li>JWT</li><li>阿里云 OSS</li><li>Swagger</li><li>POI</li><li>WebSocket</li></ul><h3 id="数据层"><a class="anchor" href="#数据层">#</a> 数据层</h3><ul><li>MySQL</li><li>Redis</li><li>mybatis</li><li>pagehelper</li><li>spring data redis</li></ul><h2 id="具体实现"><a class="anchor" href="#具体实现">#</a> 具体实现</h2><h3 id="完善登录功能"><a class="anchor" href="#完善登录功能">#</a> 完善登录功能</h3><ol><li>修改数据库中的密码，改为 MD5 加密后的密文</li><li>修改 JAVA 代码，前端提交的密码进行 MD5 加密后再跟数据库中的密码对比</li><li>抛异常使用消息常量类</li></ol><h3 id="swagger的使用"><a class="anchor" href="#swagger的使用">#</a> swagger 的使用</h3><p>swagger 可以方便的进行前后端联调，由于该项目仅涉及两位成员且沟通方便故未使用，仅学习了解过如何使用</p><h3 id="新增员工"><a class="anchor" href="#新增员工">#</a> 新增员工</h3><p>前端提交的数据与实体类差别较大，故采用 DTO 来封装数据</p><p>实体类（Entity）<br>与数据库表对应：实体类通常直接映射到数据库表，包含所有字段，便于持久化操作。<br>封装业务逻辑：实体类不仅仅是数据的载体，还可以包含业务逻辑和数据状态。<br>简化数据库操作：通过 ORM 框架（如 Hibernate），实体类可以简化数据库的增删改查操作。<br>DTO（数据传输对象）<br>数据传输优化：DTO 主要用于在不同层（如控制层和服务层）之间传输数据。它可以只包含需要传输的字段，减少不必要的数据传输，提高性能。<br>安全性：通过 DTO，可以避免直接暴露实体类中的敏感数据，增强系统的安全性。<br>解耦前后端：DTO 可以根据前端需求定制，避免前端直接依赖实体类，从而实现前后端的解耦。<br>简化数据转换：在复杂业务场景中，DTO 可以简化数据转换逻辑，避免在多个地方重复编写转换代码。<br>使用场景<br>实体类：适用于需要直接与数据库交互的场景，如 DAO 层。<br>DTO：适用于需要在不同层之间传输数据的场景，如控制层与服务层之间的数据传输。</p><h4 id="存储数据"><a class="anchor" href="#存储数据">#</a> 存储数据</h4><p>无须逐个设置实体对象属性，而是使用对象属性拷贝 ( <code>BeanUtils.copyProperties</code> ), 再设置其他 DTO 中不存在的属性</p><h4 id="插入数据"><a class="anchor" href="#插入数据">#</a> 插入数据</h4><pre><code class="language-Java">@Insert(&quot;insert into employee(name, username, password, phone) values(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;)&quot;)
void insert(Employee employee)
</code></pre><details class="success"><summary></summary><div><p>MyBatis 提供了多种注解来简化 SQL 操作，避免了繁琐的 XML 配置。以下是一些常用的 MyBatis 注解及其用途：</p><p>常用注解</p><pre><code class="language-Java">@Select：用于执行查询操作。
@Select(&quot;SELECT * FROM employee WHERE id = #&#123;id&#125;&quot;)
Employee selectById(int id);

@Insert：用于执行插入操作。
@Insert(&quot;INSERT INTO employee(name, username, password, phone) VALUES(#&#123;name&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;phone&#125;)&quot;)
void insert(Employee employee);

@Update：用于执行更新操作。
@Update(&quot;UPDATE employee SET name = #&#123;name&#125;, username = #&#123;username&#125;, password = #&#123;password&#125;, phone = #&#123;phone&#125; WHERE id = #&#123;id&#125;&quot;)
void update(Employee employee);

@Delete：用于执行删除操作。
@Delete(&quot;DELETE FROM employee WHERE id = #&#123;id&#125;&quot;)
void delete(int id);

@Results 和 @Result：用于映射查询结果到对象属性。
@Select(&quot;SELECT * FROM employee WHERE id = #&#123;id&#125;&quot;)
@Results(&#123;
    @Result(property = &quot;id&quot;, column = &quot;id&quot;),
    @Result(property = &quot;name&quot;, column = &quot;name&quot;),
    @Result(property = &quot;username&quot;, column = &quot;username&quot;),
    @Result(property = &quot;password&quot;, column = &quot;password&quot;),
    @Result(property = &quot;phone&quot;, column = &quot;phone&quot;)
&#125;)
Employee selectById(int id);

@One 和 @Many：用于一对一和一对多的关系映射。
@Select(&quot;SELECT * FROM department WHERE id = #&#123;id&#125;&quot;)
@Results(&#123;
    @Result(property = &quot;id&quot;, column = &quot;id&quot;),
    @Result(property = &quot;name&quot;, column = &quot;name&quot;),
    @Result(property = &quot;employees&quot;, column = &quot;id&quot;, 
            many = @Many(select = &quot;selectEmployeesByDepartmentId&quot;))
&#125;)
Department selectById(int id);
</code></pre></div></details><h4 id="代码完善"><a class="anchor" href="#代码完善">#</a> 代码完善</h4><h5 id="录入的用户名已存在抛出异常未处理"><a class="anchor" href="#录入的用户名已存在抛出异常未处理">#</a> 录入的用户名已存在，抛出异常未处理</h5><p>添加异常处理即可。</p><h5 id="动态获取当前登录用户id"><a class="anchor" href="#动态获取当前登录用户id">#</a> 动态获取当前登录用户 id</h5><p>这里我们使用 JWT 技术。</p><p>通过拦截器将 Token 令牌拦截，解析出用户 id，传给 save 方法。</p><p>但是拦截器中并未直接调用 save 方法，那么该如何将解析到的用户 id 传给 save 方法呢？</p><p>这里我们采用 ThreadLocal。</p><details class="success"><summary>ThreadLocal</summary><div><p><code>ThreadLocal</code> 并不是一个 Thread, 而是 Thread 的局部变量。</p><p><code>ThreadLocal</code> 为每个线程提供单独一份存储空间，具有线程隔离的效果，只有线程内才能获取到对应的值，线程外则不能访问。</p></div></details><p>通过观察 <code>ThreadId</code> 很容易发现，每一次请求都是一个线程，故可以封装上述 <code>ThreadLocal</code> , 添加 <code>setId</code> , <code>getId</code> , <code>removeId</code> 方法成一个工具类 BaseContext、</p><p>因此，在拦截器中将 Id 存入 <code>ThreadLocal</code> 然后在 save 方法中取出即可。</p><h3 id="员工分页查询"><a class="anchor" href="#员工分页查询">#</a> 员工分页查询</h3><h4 id="业务规则"><a class="anchor" href="#业务规则">#</a> 业务规则</h4><ul><li>根据页码展示员工信息</li><li>每页展示 10 条数据</li><li>分页查询时可以根据需要，输入员工的姓名进行查询</li></ul><h4 id="接口设计"><a class="anchor" href="#接口设计">#</a> 接口设计</h4><ul><li>路径：</li><li>请求方法：GET</li><li>请求参数： <code>name</code> ， <code>page</code> ， <code>pagesize</code></li></ul><h4 id="分页查询"><a class="anchor" href="#分页查询">#</a> 分页查询</h4><p>一般是通过基于 <code>SQL</code> 的 <code>limit</code> 关键字进行分页查询，如:</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employee <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span></pre></td></tr></table></figure><p>但是我们也可以使用分页查询插件，这里我使用的是 <code>pagehelper</code> , 它基于拦截器动态拼接字符串</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">PageHelper</span><span class="token punctuation">.</span><span class="token function">startPage</span><span class="token punctuation">(</span>employeePageQueryDTO<span class="token punctuation">.</span><span class="token function">getPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>employeePageQueryDTO<span class="token punctuation">.</span><span class="token function">getPageSzie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span>employee<span class="token punctuation">></span></span> <span class="token class-name">Page</span> <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">pageQuery</span><span class="token punctuation">(</span>employeePageQueryDTO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>查询是模糊查询不是等值查询，故使用 <code>like</code></p><h4 id="代码完善-2"><a class="anchor" href="#代码完善-2">#</a> 代码完善</h4><p>经测试，上述编写的代码存在数据格式的问题需要解决</p><ul><li><p>方式一：在属性上加入注解，对日期进行格式化</p><pre><code class="language-Java">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
private LocalDateTime updateTime;
</code></pre><p>但上述方式只能对单一方法进行格式化，故推荐使用方式二统一格式化</p></li><li><p>方式二：在 <code>WebMvcConfiguration</code> 中扩展 <code>SpringMVC</code> 的消息转换器，统一对日期类型进行格式化处理</p><pre><code class="language-Java">protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)&#123;
    log.warning(&quot;开始扩展消息转换器...&quot;);
    //创建一个消息转化器对象
    MappingJackson2HttpmessageConverter converter = new MappingJackson2HttpMessageConverter();
    //设置对象转换器,可以将Java对象转为json字符串
    converter.setObjectmapper(new JacksonObjectMapper());
    //将我们自己的转换器放入spring MVC框架的容器中
    converters.add(0,converter);
&#125;
</code></pre></li></ul><h3 id="启用禁用员工账号"><a class="anchor" href="#启用禁用员工账号">#</a> 启用禁用员工账号</h3><h4 id="接口设计-2"><a class="anchor" href="#接口设计-2">#</a> 接口设计</h4><ul><li>路径</li><li>请求方式：POST</li><li>请求参数：<ul><li>Headers： <code>contentType</code></li><li>路径参数: <code>status</code></li><li>Query: <code>id</code></li></ul></li><li>返回数据: <code>code</code> , <code>msg</code> , <code>data</code></li></ul><h3 id="编辑员工"><a class="anchor" href="#编辑员工">#</a> 编辑员工</h3><h3 id="公共字段自动填充"><a class="anchor" href="#公共字段自动填充">#</a> 公共字段自动填充</h3><h4 id="问题分析"><a class="anchor" href="#问题分析">#</a> 问题分析</h4><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240831172556784.png" title="image-20240831172556784"></p><p>业务表中有公共字段，逐个赋值非常麻烦，之后也难以修改，不便于后期维护</p><p>那么如何解决呢？</p><ul><li>自定义注解 AutoFill, 用于标识需要进行公共字段自动填充的方法</li><li>自定义切面类 AutoFillAspect, 统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</li><li>在 Mapper 方法上加入 AutoFill 注解</li></ul><p>技术点：枚举，注解，AOP, 反射</p><h3 id="新增菜品"><a class="anchor" href="#新增菜品">#</a> 新增菜品</h3><h4 id="需求分析"><a class="anchor" href="#需求分析">#</a> 需求分析</h4><ul><li>菜品必须是唯一的</li><li>菜品必须在某个分类下，不能单独存在</li><li>新增菜品时可根据情况选择菜品的口味</li><li>每个菜品必须对应一张图片</li></ul><h4 id="接口设计-3"><a class="anchor" href="#接口设计-3">#</a> 接口设计</h4><ul><li>根据类型查询分类 (已完成)</li><li>文件上传</li><li>新增菜品</li></ul><h4 id="文件上传"><a class="anchor" href="#文件上传">#</a> 文件上传</h4><p>使用阿里云 oss 存储上传的二进制文件</p><p>使用 UUID 来重命名，防止出现重名的情况</p><p>新增菜品和口味时涉及两张表的操作</p><p>涉及多张表 -&gt; 保证事务一致性 -&gt; 添加注解 <code>@Transactional</code></p><h3 id="菜品分类查询"><a class="anchor" href="#菜品分类查询">#</a> 菜品分类查询</h3><h3 id="删除菜品"><a class="anchor" href="#删除菜品">#</a> 删除菜品</h3><p>这里需要注意的是，如果菜品属于某一套餐，则不可随意删除，需要对菜品 - 口味关联表进行操作</p><h3 id="修改菜品"><a class="anchor" href="#修改菜品">#</a> 修改菜品</h3><h4 id="接口设计-4"><a class="anchor" href="#接口设计-4">#</a> 接口设计</h4><ul><li>根据 id 查询菜品</li><li>根据类型查询分类 (已实现)</li><li>文件上传 (已实现)</li><li>修改菜品</li></ul><h4 id="具体实现-2"><a class="anchor" href="#具体实现-2">#</a> 具体实现</h4><p>修改操作在技术层面上转化为先删除，再重新插入新的数据</p><h3 id="店铺营业状态设置"><a class="anchor" href="#店铺营业状态设置">#</a> 店铺营业状态设置</h3><h4 id="使用技术"><a class="anchor" href="#使用技术">#</a> 使用技术</h4><p>使用 <code>Spring Data Redis</code> 再 JAVA 中操作 <code>Redis</code></p><ol><li>导入 <code>Spring Data Redis</code> 的 <code>maven</code> 坐标</li><li>配置 <code>Redis</code> 数据源</li><li>编写配置类，	创建 <code>RedisTemple</code> 对象</li><li>通过 <code>RedisTemple</code> 对象操作 <code>Redis</code></li></ol><h4 id="需求分析-2"><a class="anchor" href="#需求分析-2">#</a> 需求分析</h4><ul><li>设置营业状态</li><li>管理端查询营业状态</li><li>用户端查询营业状态</li><li>营业状态数据存储方式：基于 <code>Redis</code> 的字符串来进行存储</li></ul><h3 id="微信登录"><a class="anchor" href="#微信登录">#</a> 微信登录</h3><p>添加小程序代码 (由他人开发，类似前端，由 js 文件组成)</p><h4 id="具体实现-3"><a class="anchor" href="#具体实现-3">#</a> 具体实现</h4><ol><li>​ 小程序使用 <code>wx.login()</code> 获取 <code>code</code> (授权码), 然后使用 <code>wx.request</code> 发送 code 到开发者服务器</li><li>开发者服务器获得 <code>code</code> 后使用 <code>httpclient</code> 将 <code>appid</code> , <code>appsecret</code> , <code>code</code> 发送到微信接口</li><li>微信接口返回 <code>session_key</code> 和 <code>openid</code> (微信用户唯一标识，然后用其生成一个令牌给小程序</li><li>最后小程序使用令牌来获取各种服务</li></ol><h3 id="商品与浏览功能"><a class="anchor" href="#商品与浏览功能">#</a> 商品与浏览功能</h3><h4 id="接口设计-5"><a class="anchor" href="#接口设计-5">#</a> 接口设计</h4><ul><li>查询分类</li><li>根据分类 <code>id</code> 查询菜品</li><li>根据分类 <code>id</code> 查询套餐</li><li>根据套餐 <code>id</code> 查询包含的菜品</li></ul><h3 id="缓存菜品"><a class="anchor" href="#缓存菜品">#</a> 缓存菜品</h3><h4 id="问题说明"><a class="anchor" href="#问题说明">#</a> 问题说明</h4><p>用户端小程序展示的菜品都是通过查询数据库获得，如果用户访问量比较大，数据库访问压力随之增大。</p><h4 id="实现思路"><a class="anchor" href="#实现思路">#</a> 实现思路</h4><p>通过 <code>Redis</code> 来缓存菜品数据，减少数据库查询操作</p><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901111540778.png" title="image-20240901111540778"></p><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901111924695.png" title="image-20240901111924695"></p><h3 id="缓存套餐"><a class="anchor" href="#缓存套餐">#</a> 缓存套餐</h3><h4 id="spring-cache"><a class="anchor" href="#spring-cache">#</a> Spring Cache</h4><p><code>Spring Cache</code> 是一个框架，实现了基于 <code>注解</code> 的缓存功能，只需简单地加一个注解，就能实现缓存功能</p><p><code>Spring Cache</code> 提供了一层抽象，底层可以切换不同的缓存实现，例如:</p><ul><li><code>EHCache</code></li><li><code>Caffeine</code></li><li><code>Redis</code></li></ul><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901112515899.png" title="image-20240901112515899"></p><h3 id="添加购物车"><a class="anchor" href="#添加购物车">#</a> 添加购物车</h3><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901115033152.png" title="image-20240901115033152"></p><p>对购物车表添加冗余字段，这样就无须多表联合查询，增加速度</p><h3 id="查看购物车"><a class="anchor" href="#查看购物车">#</a> 查看购物车</h3><h3 id="清空购物车"><a class="anchor" href="#清空购物车">#</a> 清空购物车</h3><h3 id="导入地址簿"><a class="anchor" href="#导入地址簿">#</a> 导入地址簿</h3><h4 id="业务功能"><a class="anchor" href="#业务功能">#</a> 业务功能</h4><ul><li>查询地址列表</li><li>新增地址</li><li>修改地址</li><li>删除地址</li><li>设置默认地址</li><li>查询默认地址</li></ul><h4 id="具体实现-4"><a class="anchor" href="#具体实现-4">#</a> 具体实现</h4><p>订单与订单明细表是一对多的关系</p><ol><li>处理各种业务异常 (地址簿为空 / 购物车为空)</li><li>向订单表插入一条数据</li><li>向订单表明细插入 n 条数据</li><li>清空当前用户的购物车数据</li><li>封装 VO 返回结果</li></ol><h3 id="微信支付"><a class="anchor" href="#微信支付">#</a> 微信支付</h3><ol><li>首先用户向商户系统 (即本项目) 发出下单请求</li><li>返回订单号</li><li>在向商户系统申请微信支付</li><li>商户系统调用微信下单接口，返回支付参数 (此时为预下单)</li><li>最后用户用支付参数调起微信支付</li><li>返回支付结果，同时商户系统获取支付结果并更新订单状态</li></ol><h3 id="订单状态定时处理"><a class="anchor" href="#订单状态定时处理">#</a> 订单状态定时处理</h3><h4 id="spring-task"><a class="anchor" href="#spring-task">#</a> Spring Task</h4><p><code>Spring Task</code> 是 <code>Spring</code> 框架提供的任务调度工具，可以按照	约定的时间自动执行某个代码逻辑</p><h4 id="cron表达式"><a class="anchor" href="#cron表达式">#</a> cron 表达式</h4><p><code>cron</code> 表达式其实就是一个字符串，通过 <code>cron</code> 表达式可以 <code>定义任务触发的时间</code></p><p>构成规则：分为 <code>6</code> 或 <code>7</code> 个域，由空格分隔开，每个域代表一个含义 (秒 / 分钟 / 小时 / 日 / 月 / 周 / 年 (可选))</p><p><img data-src="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901134936435.png" title="image-20240901134936435"></p><p>在线生成 <code>cron</code> 表达式</p><p><span class="exturl" data-url="aHR0cHM6Ly9jcm9uLnFxZTIuY29tLw==">在线 Cron 表达式生成器 (qqe2.com)</span></p><h4 id="需求分析-3"><a class="anchor" href="#需求分析-3">#</a> 需求分析</h4><p>问题:</p><ul><li>用户下单后未支付，订单一直处于 <code>&quot;待支付&quot;</code> 状态</li><li>用户收货后管理端未点击完成按钮，订单一直处于 <code>&quot;派送中&quot;</code> 状态</li></ul><p>解决:</p><ul><li>通过定时任务 <code>每分钟检查一次</code> 是否存在超时订单 (下单后超过 15 分钟未支付), 如果则存在修改为 &quot;已取消&quot;</li><li>通过定时任务 <code>每天凌晨检查一次</code> 是否存在 &quot;派送中&quot; 的订单，如果存在则修改为 &quot;已完成&quot;</li></ul><h3 id="来单提醒"><a class="anchor" href="#来单提醒">#</a> 来单提醒</h3><h4 id="websocket"><a class="anchor" href="#websocket">#</a> WebSocket</h4><p><code>WebSocket</code> 是基于 <code>TCP</code> 的一种新的网络协议。它实现了浏览器与服务器全双工通信 —— 浏览器和服务器只需要完成一次握手，两者之间就可以创建 <code>持久性</code> 的连接，并进行 <code>双向</code> 数据传输。</p><h4 id="需求分析-4"><a class="anchor" href="#需求分析-4">#</a> 需求分析</h4><p>用户下单并且支付成功后，需要第一时间通知外卖商家。通知形式有如下两种：</p><ul><li>语言播报</li><li>弹出提示框</li></ul><p>设计：</p><ul><li>通过 <code>WebSocket</code> 实现管理端页面和服务端保持长连接状态</li><li>当客户支付后，调用 <code>WebSocket</code> 的相关 <code>API</code> 实现服务端向客户端推送消息</li><li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li><li>约定服务端发送给客户端浏览器的数据格式为 <code>JSON</code> , 字段包括: <code>type</code> , <code>orderId</code> , <code>content</code><ul><li><code>type</code> 为消息类型， <code>1</code> 为来单提醒， <code>2</code> 为客户催单</li><li><code>orderId</code> 为订单 <code>id</code></li><li><code>content</code> 为消息内容</li></ul></li></ul><h3 id="营业额统计"><a class="anchor" href="#营业额统计">#</a> 营业额统计</h3><h4 id="apache-echarts"><a class="anchor" href="#apache-echarts">#</a> Apache ECharts</h4><p>使用 <code>ECharts</code> , 重点在于研究当前图表所需的 <code>数据格式</code> 。通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。</p><h3 id="用户统计"><a class="anchor" href="#用户统计">#</a> 用户统计</h3><p>统计用户数量</p><h3 id="订单统计"><a class="anchor" href="#订单统计">#</a> 订单统计</h3><h3 id="销量排名统计"><a class="anchor" href="#销量排名统计">#</a> 销量排名统计</h3><h3 id="工作台"><a class="anchor" href="#工作台">#</a> 工作台</h3><p>工作台是系统运营的看板，并提供快捷操作入口，可以有效提高商家的工作效率</p><p>工作台展示的数据</p><ul><li>今日数据</li><li>订单管理</li><li>菜品总览</li><li>套餐总览</li><li>订单信息</li></ul><p>每组数据对应一个接口，减少代码耦合性</p><h3 id="导出运营数据excel报表"><a class="anchor" href="#导出运营数据excel报表">#</a> 导出运营数据 Excel 报表</h3><h4 id="apache-poi"><a class="anchor" href="#apache-poi">#</a> Apache POI</h4><p><code>Apache POI</code> 是一个处理 <code>Microsoft Office</code> 各种文件格式的开源项目。简单来说就是，我们可以使用 <code>POI</code> 在 <code>Java</code> 程序中对 <code>Microsoft Office</code> 各种文件进行读写操作。</p><p>一般情况下， <code>POI</code> 都是用于操作 <code>Excel</code> 文件。</p><p>应用场景：</p><ul><li>银行网银系统导出交易明细</li><li>各种业务系统导出 <code>Excel</code> 报表</li><li>批量导入业务数据</li></ul><h4 id="需求分析-5"><a class="anchor" href="#需求分析-5">#</a> 需求分析</h4><ul><li>导出 <code>Excel</code> 形式的报表文件</li><li>导出最近 30 天的运营数据</li></ul><p><code>当前接口没有返回数据,因为报表导出的本质是文件下载</code></p><p>服务端会通过输出流将 <code>Excel</code> 文件下载到客户端浏览器</p><h2 id="亮点难点"><a class="anchor" href="#亮点难点">#</a> 亮点难点</h2><h3 id="nginx反向代理和负载均衡"><a class="anchor" href="#nginx反向代理和负载均衡">#</a> Nginx 反向代理和负载均衡</h3><p><code>Nginx</code> 是一款轻量级的 <code>web</code> 服务器，反向代理服务器、电子邮件代理服务器，特点是占有内存少、并发能力强。Nginx 反向代理就是将前端发送的动态请求由 Nginx 转发到后端服务器，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p><p>Nginx 反向代理的好处：</p><ul><li>提高访问速度：因为 nginx 本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx 就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</li><li>进行负载均衡：所谓负载均衡，就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</li><li>保证后端服务安全：因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把 nginx 作为请求访问的入口，请求到达 nginx 后转发到具体的服务中，从而保证后端服务的安全。</li></ul><details class="success"><summary>负载均衡</summary><div><p>负载均衡（Load Balancing）是一种技术，用于将网络流量或工作负载分配到多个服务器或计算资源上，以提高系统的性能、可靠性和可扩展性。它的主要目标是确保每个服务器的负载尽可能均衡，从而避免单个服务器过载，提升整体系统的响应速度和可用性。</p><p>负载均衡的实现方式</p><ol><li>硬件负载均衡<br>硬件负载均衡器是专用设备，通常具有高性能和高可靠性。常见的硬件负载均衡器包括 F5 和 A10。</li></ol><p>优点：性能强大，支持复杂的负载均衡算法，安全性高。<br>缺点：成本高，扩展性差。</p><ol start="2"><li>软件负载均衡<br>软件负载均衡器运行在标准服务器上，常见的有 Nginx、HAProxy 和 LVS。</li></ol><p>优点：成本低，扩展性好，易于部署和维护。<br>缺点：性能相对硬件负载均衡器略低。<br>负载均衡的常见算法<br>轮询（Round Robin）：将请求依次分配给每个服务器，适用于负载均衡器和服务器性能相近的情况。<br>加权轮询（Weighted Round Robin）：根据服务器的性能分配权重，性能高的服务器分配更多请求。<br>最少连接（Least Connections）：将请求分配给当前连接数最少的服务器，适用于长连接的情况。<br>源地址哈希（Source IP Hash）：根据请求源 IP 地址的哈希值分配服务器，适用于需要会话保持的情况。<br>负载均衡的应用场景<br>Web 服务器集群：通过负载均衡分配 HTTP 请求，提高网站的并发处理能力。<br>数据库集群：分配数据库查询请求，提升数据库的读写性能。<br>微服务架构：在微服务架构中，负载均衡用于分配服务请求，确保各个服务实例的负载均衡。</p></div></details><h3 id="使用jwt"><a class="anchor" href="#使用jwt">#</a> 使用 JWT</h3><p>原本计划使用 Session 和验证码，考虑到如下因素最后选择了 <code>JWT</code></p><p>使用 JWT（JSON Web Token）相比传统的 Session 和验证码有以下几个优点：</p><ol><li><p>无状态性<br>优点：JWT 是无状态的，服务器不需要存储会话信息。每个请求都携带 JWT，服务器只需验证 JWT 的有效性即可。这使得 JWT 非常适合分布式系统和微服务架构。</p></li><li><p>可扩展性<br>优点：由于 JWT 包含了用户信息和声明，可以在不同的服务器之间传递和验证。这解决了 Session 在跨服务器交换数据时的局限性。</p></li><li><p>减少服务器负担<br>优点：JWT 存储在客户端（如 Local Storage 或 Cookie 中），每次请求都携带 JWT，减少了服务器的会话管理开销。这对于高并发应用尤其有利。</p></li><li><p>跨语言支持<br>优点：JWT 采用 JSON 格式，易于读写，适用于多种编程语言。这使得 JWT 在不同技术栈之间的集成变得更加容易。</p></li><li><p>安全性<br>优点：JWT 通过签名机制确保数据的完整性和真实性。虽然 JWT 的 Payload 部分没有加密，但签名可以防止数据被篡改。</p></li><li><p>灵活性<br>优点：JWT 可以存储一些常用信息，用于交换信息。这可以减少服务器查询数据库的次数，提高性能。</p></li><li><p>适用于移动端和单页应用<br>优点：JWT 特别适合移动端应用和单页应用（SPA），因为它们通常需要跨域请求和无状态认证。</p></li><li><p>简化认证流程<br>优点：JWT 可以简化认证流程，用户登录后，服务器生成 JWT 并返回给客户端，客户端在后续请求中携带 JWT 即可。</p></li></ol><p>当然，JWT 也有一些缺点，比如：</p><ul><li>安全性：由于 Payload 部分没有加密，不能存储敏感数据。</li><li>性能：JWT 较长，每次请求都携带 JWT，可能增加网络传输开销。</li></ul><h3 id="高并发处理"><a class="anchor" href="#高并发处理">#</a> 高并发处理</h3><p>由于菜品表，套餐表都存储在硬盘上，故当多人请求时，难免会出现卡顿，影响用户体验，因此我使用 <code>Redis</code> 进行缓存。这样由于数据存储在内存中，数据获取效率大大提升.</p><h2 id="细节补充"><a class="anchor" href="#细节补充">#</a> 细节补充</h2><h3 id="实现功能"><a class="anchor" href="#实现功能">#</a> 实现功能</h3><h4 id="管理端-2"><a class="anchor" href="#管理端-2">#</a> 管理端</h4><p>实现了员工，分类，菜品，套餐，订单管理</p><p>工作台用于快速到达所需功能，来单提醒用于接单</p><p>最后还有数据统计，包括可视化图表与 <code>excel</code> 导出</p><h4 id="用户端-2"><a class="anchor" href="#用户端-2">#</a> 用户端</h4><p>用户端主要使用微信小程序进行下单</p><p>包括常见的微信登录，支付，商品浏览下单，购物车</p><p>历史订单，地址管理，用户催单功能</p><h3 id="细节问题"><a class="anchor" href="#细节问题">#</a> 细节问题</h3><details class="success"><summary>该项目有哪些模块，作用分别是什么</summary><div><table><thead><tr><th>序号</th><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>sky-take-out</td><td>maven 父工程，统一管理依赖版本，聚合其他子模块</td></tr><tr><td>2</td><td>sky-common</td><td>子模块，存放公共类，例如：工具类、常量类、异常类等</td></tr><tr><td>3</td><td>sky-pojo</td><td>子模块，存放实体类、VO、DTO 等</td></tr><tr><td>4</td><td>sky-server</td><td>子模块，后端服务，存放配置文件、Controller、Service、Mapper 等</td></tr></tbody></table></div></details><details class="success"><summary>概述登录流程怎么实现的，为什么要加拦截器</summary><div><h3 id="登录流程"><a class="anchor" href="#登录流程">#</a> 登录流程</h3><ol><li><strong>用户提交登录请求</strong>：用户在前端输入用户名和密码，提交登录请求。</li><li><strong>服务器验证用户信息</strong>：服务器接收到请求后，验证用户名和密码是否正确。</li><li><strong>生成 JWT 令牌</strong>：如果验证通过，服务器生成一个 JWT（JSON Web Token）令牌，并将其返回给前端。</li><li><strong>前端存储令牌</strong>：前端接收到 JWT 令牌后，将其存储在本地（如 LocalStorage 或 SessionStorage）。</li><li><strong>携带令牌访问受保护资源</strong>：在后续的请求中，前端会在请求头中携带 JWT 令牌，以访问受保护的资源。</li></ol><h3 id="为什么要加拦截器"><a class="anchor" href="#为什么要加拦截器">#</a> 为什么要加拦截器</h3><p>拦截器在登录流程中起到了关键作用，主要有以下几个原因：</p><ol><li><strong>验证请求合法性</strong>：拦截器可以在每次请求到达服务器之前，检查请求头中是否包含有效的 JWT 令牌。如果没有令牌或令牌无效，拦截器可以直接拒绝请求，确保只有合法用户才能访问受保护的资源。</li><li><strong>简化代码</strong>：通过拦截器，可以将令牌验证的逻辑集中处理，避免在每个受保护的接口中重复编写验证代码，提高代码的可维护性。</li><li><strong>增强安全性</strong>：拦截器可以防止未授权的访问，保护敏感数据和功能不被非法用户获取。</li></ol></div></details><details class="success"><summary>ThreadLocal作用是什么，怎么使用的</summary><div><p>是线程的局部变量，在登录过程中，作为媒介，将用户 <code>id</code> 传给 save 方法保存信息</p></div></details><details class="success"><summary>为什么做全局异常处理，怎么实现的</summary><div><p>原因：抛出的自定义异常不会提示给用户，真正出异常又会给客户端一堆看不懂的提示，因此需要全局异常处理</p><p>实现：server 模块下，exception 文件夹下</p></div></details><details class="success"><summary>分类删除注意什么问题？怎么实现的</summary><div><h3 id="注意事项"><a class="anchor" href="#注意事项">#</a> 注意事项</h3><ol><li><strong>检查关联数据</strong>：<ul><li><strong>菜品</strong>：确保该分类下没有关联的菜品。如果有，需要先处理这些菜品（如重新分类或删除）。</li><li><strong>套餐</strong>：确保该分类下没有关联的套餐。</li></ul></li><li><strong>数据完整性</strong>：<ul><li><strong>事务管理</strong>：使用事务管理，确保删除操作的原子性，避免部分删除导致数据不一致。</li><li><strong>级联删除</strong>：如果有级联关系（如分类删除后需要删除关联的菜品），需要确保级联删除的正确性。</li></ul></li><li><strong>业务规则</strong>：<ul><li><strong>状态检查</strong>：通常不允许删除正在使用中的分类（如有菜品正在销售）。</li><li><strong>权限控制</strong>：确保只有有权限的用户才能执行删除操作。</li></ul></li></ol><h3 id="实现步骤"><a class="anchor" href="#实现步骤">#</a> 实现步骤</h3><ol><li><strong>检查关联数据</strong>：<ul><li>在删除分类前，查询该分类下是否有菜品或套餐。</li></ul></li><li><strong>删除分类</strong>：<ul><li>如果没有关联数据，可以安全删除分类。</li></ul></li><li><strong>事务管理</strong>：<ul><li>使用 <code>@Transactional</code> 注解确保操作的原子性。</li></ul></li></ol></div></details><details class="success"><summary>AOP字段填充怎么实现的</summary><div><ol><li><p>自定义注解</p><p>用于标识需要自动填充字段的方法</p></li><li><p>定义切面类</p><p>创建一个切面类，拦截带有 <code>@AutoFill</code> 注解的方法，并通过反射为实体对象的公共字段赋值</p></li><li><p>在 <code>Mapper</code> 方法上使用注解</p><p>在需要自动填充字段的方法上添加 <code>@AutoFill</code> 注解</p></li></ol></div></details><details class="success"><summary>文件上传有哪些方式，项目中怎么实现的</summary><div><ul><li><p><strong>本地存储</strong>：</p><ul><li><strong>优点</strong>：开发简单，成本低。</li><li><strong>缺点</strong>：扩展性差，服务器存储空间有限。</li><li>实现步骤：<ol><li>前端通过表单上传文件，使用 <code>multipart/form-data</code> 编码类型。</li><li>后端接收文件并保存到服务器指定目录。</li><li>返回文件的访问路径给前端。</li></ol></li></ul></li><li><p><strong>云存储（如阿里云 OSS）</strong>：</p><ul><li><strong>优点</strong>：扩展性好，支持大规模存储，免维护。</li><li><strong>缺点</strong>：需要付费。</li><li>实现步骤：<ol><li>配置阿里云 OSS 相关信息（如 endpoint、accessKeyId、accessKeySecret、bucketName）。</li><li>使用阿里云 OSS SDK 上传文件到云存储。</li><li>返回文件的访问路径给前端。</li></ol></li></ul><p>之前学习的项目都是本地存储，本着尝试的目的，并且作为学生可以试用阿里云 oss, 故使用阿里云 oss, 采用云存储的方式上传图片</p></li></ul></div></details><details class="success"><summary>菜品分页需要关联展示分类名称，怎么实现的</summary><div><p>前端提交的数据与实体类差距较大，例如状态，时间等是实体类没有的，故使用 DTO 类封装数据，然后就是惯例的 <code>Mapper</code> , <code>Controller</code> , <code>Service</code> .</p></div></details><details class="success"><summary>菜品修改时，关联的菜品口味如何修改的</summary><div><ol><li><strong>获取菜品信息</strong>：<ul><li>首先，从数据库中获取需要修改的菜品信息，包括其关联的口味信息。</li></ul></li><li><strong>修改菜品信息</strong>：<ul><li>更新菜品的基本信息，如名称、价格、描述等。</li></ul></li><li><strong>更新关联的口味信息</strong>：<ul><li>根据菜品的 ID，查询并更新其关联的口味信息。可以使用 MyBatis 的关联查询功能来实现这一点。</li></ul></li><li><strong>保存修改</strong>：<ul><li>将修改后的菜品信息和口味信息保存到数据库中。</li></ul></li></ol></div></details><details class="success"><summary>菜品起售停售注意事项，如何实现</summary><div><p>这里要考虑的是数据一致性，确保菜品状态的修改不会影响其他关联数据的完整性。</p><p>例如，停售菜品要检查是否有未完成的订单。</p><p>由于涉及多表操作，建议使用事务管理来确保数据的一致性和操作的原子性</p></div></details><details class="success"><summary>概述HttpClient的作用</summary><div><p><code>HttpClient</code> 的主要作用是<strong>发送 HTTP 请求和接收响应数据</strong></p><p>在本项目中， <code>HttpClient</code> 是将授权码 <code>code</code> 及 <code>appId</code> 和 <code>appsecret</code> 发送到微信接口</p></div></details><details class="success"><summary>概述微信登录实现流程</summary><div><ol><li>​ 小程序使用 <code>wx.login()</code> 获取 <code>code</code> (授权码), 然后使用 <code>wx.request</code> 发送 code 到开发者服务器</li><li>开发者服务器获得 <code>code</code> 后使用 <code>httpclient</code> 将 <code>appid</code> , <code>appsecret</code> , <code>code</code> 发送到微信接口</li><li>微信接口返回 <code>session_key</code> 和 <code>openid</code> (微信用户唯一标识，然后用其生成一个令牌给小程序</li><li>最后小程序使用令牌来获取各种服务</li></ol></div></details><details class="success"><summary>小程序首页菜品数据怎么查询的</summary><div><p>这部分是由他人负责的，但根据我的了解，主要还是后端编写查询接口，前端通过 <code>wx.request</code> 方法发送 <code>HTTP</code> 请求获取数据的</p></div></details><details class="success"><summary>小程序首页套餐数据怎么查询的</summary><div><p>同上</p></div></details><details class="success"><summary>redis中有哪些数据类型</summary><div><p>常见的有 <code>String</code> , <code>Hash</code> , <code>List</code> , <code>Set</code> , <code>ZSet</code> 等</p></div></details><details class="warning"><summary>概述菜品缓存流程</summary><div></div></details><details class="warning"><summary>数据库与redis如何实现的数据同步</summary><div></div></details><details class="warning"><summary>为什么用了redis还用SpringCache</summary><div></div></details><details class="warning"><summary>SpringCache有哪些注解</summary><div></div></details><details class="warning"><summary>SpringCache在项目中如何使用的</summary><div></div></details><details class="warning"><summary>概述添加购物车流程</summary><div></div></details><details class="warning"><summary>概述订单提交实现流程</summary><div></div></details><details class="warning"><summary>概述历史订单实现流程</summary><div></div></details><details class="warning"><summary>概述再来一单实现流程</summary><div></div></details><details class="warning"><summary>定时任务如何实现的</summary><div></div></details><details class="warning"><summary>cron表达式有哪些特殊符号，分别表示什么意思</summary><div></div></details><details class="warning"><summary>项目中定时任务如何使用的</summary><div><p>使用 <code>cron</code> 表达式</p></div></details><details class="warning"><summary>说说WebSocket和HTTP协议的区别</summary><div></div></details><details class="warning"><summary>项目中用WebSocket实现了哪些功能，怎么实现的</summary><div></div></details><details class="warning"><summary>营业额统计数据如何设计VO对象封装的</summary><div></div></details><details class="success"><summary>Excel导入导出有哪些技术方案？</summary><div><p>有很多，我最终使用的是 <code>Apache POI</code> , 针对 <code>Microsoft Office</code> 的开源项目</p></div></details><details class="success"><summary>JWT储存在前端的哪个地方</summary><div><p>在前端存储 JWT（JSON Web Token）时，有几种常见的方法，每种方法都有其优缺点：</p><p>Local Storage：<br>优点：易于实现，持久化存储，即使刷新页面也不会丢失。<br>缺点：容易受到 XSS（跨站脚本）攻击，因为任何运行在同一域上的 JavaScript 代码都可以访问 Local Storage。<br>Session Storage：<br>优点：与 Local Storage 类似，但数据仅在会话期间有效，浏览器关闭后数据会被清除。<br>缺点：同样容易受到 XSS 攻击。<br>Cookies：<br>优点：可以设置 HttpOnly 和 Secure 标志，增加安全性。HttpOnly 标志可以防止 JavaScript 访问 Cookie，从而减少 XSS 攻击的风险。Secure 标志确保 Cookie 只能通过 HTTPS 传输。<br>缺点：需要处理 CSRF（跨站请求伪造）攻击，可以通过使用 SameSite 属性来缓解。<br>内存中：<br>优点：最安全，因为数据仅在内存中存储，页面刷新或关闭浏览器后数据会丢失。<br>缺点：用户每次刷新页面或关闭浏览器后需要重新登录。<br>综合考虑安全性和易用性，使用 HttpOnly 和 Secure 标志的 Cookie 是推荐的存储方式。这种方法可以有效防止 XSS 攻击，同时通过适当的配置减少 CSRF 攻击的风险。</p></div></details><details class="success"><summary>项目涉及https传输，说说其原理</summary><div><p>HTTPS（HyperText Transfer Protocol Secure）是 HTTP 的安全版本，用于在客户端（如浏览器）和服务器之间安全地传输数据。它通过加密通信来保护数据的机密性和完整性。以下是 HTTPS 的工作原理：</p><p>SSL/TLS 协议：<br>HTTPS 使用 SSL（Secure Sockets Layer）或其后继者 TLS（Transport Layer Security）协议来加密数据传输。TLS 是目前更常用的协议。<br>这些协议通过加密数据来防止数据在传输过程中被窃取或篡改。<br>公钥和私钥：<br>HTTPS 使用一种称为非对称加密的技术，这种技术使用一对密钥：公钥和私钥。<br>公钥用于加密数据，任何人都可以获取公钥并使用它来加密数据。<br>私钥用于解密数据，只有服务器拥有私钥。<br>SSL/TLS 证书：<br>服务器需要一个 SSL/TLS 证书来启用 HTTPS。证书由受信任的证书颁发机构（CA）签发，包含公钥和服务器的身份信息。<br>当客户端连接到服务器时，服务器会发送其 SSL/TLS 证书给客户端。<br>握手过程：<br>客户端和服务器通过一个称为握手的过程来建立安全连接。<br>在握手过程中，客户端验证服务器的证书，确保其真实性。<br>一旦验证通过，客户端和服务器将生成一个对称密钥，用于加密后续的通信。对称加密比非对称加密更快，因此用于实际的数据传输。<br>数据加密：<br>一旦握手完成，客户端和服务器之间的所有数据传输都将使用对称密钥进行加密。<br>这确保了即使数据在传输过程中被截获，攻击者也无法解密和读取数据。<br>通过这些步骤，HTTPS 提供了一个安全的通信渠道，保护敏感信息（如密码、信用卡信息等）在传输过程中的安全。</p></div></details><details class="success"><summary>如何设计一个短信验证码登录</summary><div><ol><li><strong>前端请求验证码</strong>：<ul><li>用户在登录页面输入手机号码并点击获取验证码按钮。</li><li>前端发送请求到后端，要求发送短信验证码。</li></ul></li><li><strong>后端生成验证码</strong>：<ul><li>后端生成一个随机的验证码（通常是 6 位数字）。</li><li>将验证码和手机号码关联，并存储在缓存中（如 Redis），设置一个有效期（如 5 分钟）。</li></ul></li><li><strong>发送短信验证码</strong>：<ul><li>使用第三方短信服务（如阿里云短信服务、腾讯云短信服务等）将验证码发送到用户的手机号码。</li><li>确保短信内容简洁明了，包含验证码和有效期提示。</li></ul></li><li><strong>用户输入验证码登录</strong>：<ul><li>用户在登录页面输入收到的验证码和手机号码，并提交登录请求。</li><li>前端将手机号码和验证码发送到后端进行验证。</li></ul></li><li><strong>后端验证验证码</strong>：<ul><li>后端接收到登录请求后，从缓存中获取存储的验证码。</li><li>验证用户输入的验证码是否正确且在有效期内。</li><li>如果验证通过，生成 JWT（JSON Web Token）或其他类型的令牌，并返回给前端。</li></ul></li><li><strong>前端存储令牌</strong>：<ul><li>前端接收到令牌后，将其存储在合适的位置（如 Local Storage、Session Storage 或 Cookie）。</li><li>在后续的请求中，前端将令牌包含在请求头中，以便后端进行身份验证。</li></ul></li></ol></div></details><details class="success"><summary>怎么拦截获取验证码的重复请求</summary><div><p>为了防止用户重复请求验证码，可以采取以下几种方法：</p><p>前端按钮禁用：<br>在用户点击获取验证码按钮后，将按钮禁用一段时间（例如 60 秒），防止用户在短时间内多次点击。<br>可以使用 JavaScript 设置一个倒计时，倒计时结束后重新启用按钮。</p><p>后端请求频率限制：<br>在后端设置一个请求频率限制，例如每个手机号码每分钟只能请求一次验证码。<br>可以使用 Redis 等缓存工具来存储请求时间，并在每次请求时检查是否超过了限制。</p><p>唯一请求标识：<br>使用唯一请求标识（如 UUID）来标识每个请求，并在后端记录这些标识。<br>如果检测到重复的请求标识，则拒绝处理该请求。</p><p>通过这些方法，可以有效地防止用户重复请求验证码，提升系统的安全性和用户体验。</p></div></details><details class="success"><summary>get与post的区别</summary><div><p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在使用场景和特性上有一些重要的区别：</p><p>用途：<br>GET：主要用于从服务器获取数据。请求参数会附加在 URL 后面。<br>POST：主要用于向服务器提交数据。请求参数包含在请求体中。<br>安全性：<br>GET：参数暴露在 URL 中，容易被截获，不适合传输敏感信息。<br>POST：参数在请求体中，相对更安全，但仍需使用 HTTPS 保护数据传输。<br>数据长度限制：<br>GET：由于 URL 长度限制，传输的数据量有限（通常不超过 2048 个字符）。<br>POST：没有数据长度限制，可以传输大量数据。<br>幂等性：<br>GET：是幂等的，多次请求同一资源不会改变服务器状态。<br>POST：不是幂等的，多次请求可能会导致不同的结果（如多次提交表单）。<br>缓存：<br>GET：请求可以被缓存，适合获取静态资源。<br>POST：请求不会被缓存，适合提交动态数据。<br>浏览器行为：<br>GET：请求参数会保留在浏览器历史记录中，可以被书签保存。<br>POST：请求参数不会保留在浏览器历史记录中，不能被书签保存。<br>这些区别决定了 GET 和 POST 在不同场景下的适用性。例如，GET 适用于获取数据而不改变服务器状态的操作，而 POST 适用于提交数据或改变服务器状态的操作。</p></div></details><details class="success"><summary>简述一个HTTP请求结构</summary><div><p>一个 HTTP 请求由以下几个部分组成：</p><ol><li><p><strong>请求行（Request Line）</strong>：</p><ul><li><strong>方法（Method）</strong>：指定要执行的操作，如 GET、POST、PUT、DELETE 等。</li><li><strong>请求 URI（Request URI）</strong>：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li><li><strong>HTTP 版本（HTTP Version）</strong>：如 HTTP/1.1 或 HTTP/2。</li></ul><p>示例：</p><pre><code>GET /index.html HTTP/1.1
</code></pre></li><li><p><strong>请求头部（Request Headers）</strong>：</p><ul><li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li><li>常见的请求头包括 Host、User-Agent、Accept、Accept-Encoding、Content-Length 等。</li></ul><p>示例：</p><pre><code>Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
</code></pre></li><li><p><strong>空行（Blank Line）</strong>：</p><ul><li>请求头和请求体之间的分隔符，表示请求头的结束。</li></ul></li><li><p><strong>请求体（Request Body）</strong>（可选）：</p><ul><li>在某些类型的 HTTP 请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li></ul><p>示例：</p><pre><code>param1=value1&amp;param2=value2
</code></pre></li></ol><p>一个完整的 HTTP 请求示例如下：</p><pre><code>GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: keep-alive
</code></pre><p>在这个示例中，请求行指定了使用 GET 方法请求 <code>/index.html</code> 资源，使用 HTTP/1.1 协议。请求头部包含了主机名、用户代理、接受的内容类型和编码方式等信息。由于这是一个 GET 请求，没有请求体。</p></div></details><details class="success"><summary>GET可以传输数据吗</summary><div><p>GET 请求可以传输数据，但数据是通过 URL 参数传递的，而不是在请求体中。具体来说，GET 请求会将数据附加在 URL 的查询字符串中。例如：</p><p>GET /search?q=example HTTP/1.1<br>Host: <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==">www.example.com</span></p><p>在这个例子中，q=example 是通过 URL 参数传递的数据。</p><p>需要注意的是，GET 请求有一些限制和特点：</p><p>数据长度限制：由于 URL 长度有限（通常不超过 2048 个字符），GET 请求传输的数据量有限。<br>安全性：因为数据暴露在 URL 中，GET 请求不适合传输敏感信息，如密码或个人数据。<br>缓存：GET 请求可以被缓存，这对于获取静态资源非常有用。<br>幂等性：GET 请求是幂等的，多次请求同一资源不会改变服务器状态。<br>如果需要传输大量数据或敏感信息，建议使用 POST 请求，因为 POST 请求的数据包含在请求体中，不会暴露在 URL 中。</p></div></details><details class="success"><summary>进程与线程</summary><div><p>进程和线程是操作系统中的两个重要概念，它们在计算机系统中扮演着不同的角色。</p><h3 id="进程"><a class="anchor" href="#进程">#</a> 进程</h3><ul><li><strong>定义</strong>：进程是一个正在运行的程序实例，是操作系统进行资源分配和调度的基本单位。</li><li>特点：<ul><li>每个进程都有独立的内存空间，包括代码段、数据段、堆和栈。</li><li>进程之间相互独立，一个进程的崩溃不会影响其他进程。</li><li>进程切换开销较大，因为需要保存和恢复大量的上下文信息。</li></ul></li></ul><h3 id="线程"><a class="anchor" href="#线程">#</a> 线程</h3><ul><li><strong>定义</strong>：线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。</li><li>特点：<ul><li>线程共享进程的内存空间（代码段、数据段、堆），但每个线程有自己的栈和寄存器。</li><li>线程之间的切换开销较小，因为共享了进程的大部分资源。</li><li>一个进程可以包含多个线程，这些线程可以并发执行，提高程序的执行效率。</li></ul></li></ul><h3 id="进程与线程的区别"><a class="anchor" href="#进程与线程的区别">#</a> 进程与线程的区别</h3><ol><li><strong>资源分配</strong>：进程是资源分配的基本单位，而线程是 CPU 调度的基本单位。</li><li><strong>内存空间</strong>：进程有独立的内存空间，线程共享进程的内存空间。</li><li><strong>开销</strong>：进程切换开销大，线程切换开销小。</li><li><strong>独立性</strong>：进程之间相互独立，一个进程的崩溃不会影响其他进程；而线程之间相互依赖，一个线程的崩溃可能导致整个进程崩溃。</li></ol><h3 id="实际应用"><a class="anchor" href="#实际应用">#</a> 实际应用</h3><p>在实际开发中，使用多线程可以提高程序的并发性和响应速度。例如，在一个 Web 服务器中，可以为每个请求创建一个线程来处理，从而提高服务器的吞吐量和响应速度。</p></div></details><details class="success"><summary>TCP，UDP以及IP相关知识</summary><div><ol><li>TCP 和 UDP 的区别<br>考察点：</li></ol><p>是否了解 TCP 和 UDP 的基本特性和应用场景。<br>回答思路：</p><p>连接性：TCP 是面向连接的协议，需要建立连接（通过三次握手）后才能传输数据；UDP 是无连接的协议，不需要建立连接。<br>可靠性：TCP 提供可靠的数据传输，具有确认应答、重传机制和流量控制；UDP 不保证数据的可靠性，适用于实时应用。<br>传输方式：TCP 是面向字节流的，数据按顺序传输；UDP 是面向报文的，每个报文独立传输。<br>开销：TCP 的首部较大（20 字节），UDP 的首部较小（8 字节）。<br>应用场景：TCP 适用于需要可靠传输的场景，如文件传输、邮件；UDP 适用于对速度要求高但对可靠性要求低的场景，如视频直播、在线游戏。<br>2. TCP 的可靠性机制<br>考察点：</p><p>是否了解 TCP 如何保证数据传输的可靠性。<br>回答思路：</p><p>校验和：用于检测数据在传输过程中是否被篡改。<br>确认应答和序列号：每个数据包都有序列号，接收方收到数据后会发送确认应答（ACK），发送方只有收到 ACK 后才会发送下一个数据包。<br>超时重传：如果发送方在一定时间内没有收到 ACK，会重传数据包。<br>流量控制：通过滑动窗口机制，控制发送方的发送速度，以适应接收方的处理能力。<br>拥塞控制：通过慢启动、拥塞避免、快速重传和快速恢复等算法，防止网络拥塞。<br>3. TCP 的三次握手和四次挥手<br>考察点：</p><p>是否了解 TCP 连接的建立和关闭过程。<br>回答思路：</p><p>三次握手：<br>客户端发送 SYN 报文，表示请求建立连接。<br>服务器收到 SYN 后，发送 SYN-ACK 报文，表示同意建立连接。<br>客户端收到 SYN-ACK 后，发送 ACK 报文，连接建立完成。<br>四次挥手：<br>客户端发送 FIN 报文，表示请求关闭连接。<br>服务器收到 FIN 后，发送 ACK 报文，表示同意关闭连接。<br>服务器发送 FIN 报文，表示准备关闭连接。<br>客户端收到 FIN 后，发送 ACK 报文，连接关闭完成。<br>4. IP 协议<br>考察点：</p><p>是否了解 IP 协议的基本概念和功能。<br>回答思路：</p><p>IP 地址：用于标识网络中的设备，每个设备都有一个唯一的 IP 地址。<br>路由：IP 协议负责将数据包从源地址传输到目标地址，通过路由器进行转发。<br>分片和重组：如果数据包超过网络的最大传输单元（MTU），IP 协议会将其分片传输，并在目标地址进行重组。<br>版本：IPv4 和 IPv6 是两种主要的 IP 协议版本，IPv6 提供了更大的地址空间和更好的安全性。</p></div></details><details class="success"><summary>DNS相关知识</summary><div><p>DNS（Domain Name System）服务器是互联网的一项基础服务，用于将域名转换为对应的 IP 地址，使用户能够通过易记的域名访问网站，而不是复杂的数字 IP 地址。以下是 DNS 服务器的相关知识：</p><h3 id="dns-服务器的工作原理"><a class="anchor" href="#dns-服务器的工作原理">#</a> DNS 服务器的工作原理</h3><ol><li><strong>域名解析</strong>：<ul><li>当用户在浏览器中输入一个域名（如 <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==">www.example.com</span>）时，浏览器会向 DNS 服务器发送查询请求，询问该域名对应的 IP 地址。</li><li>DNS 服务器会查找其数据库，如果找到匹配的记录，就返回对应的 IP 地址。</li></ul></li><li><strong>分层结构</strong>：<ul><li>DNS 采用分层结构，包括根域名服务器、顶级域名服务器（如 .com、.org）、权威域名服务器和本地域名服务器。</li><li>查询请求会从本地域名服务器开始，如果本地没有缓存记录，则逐级向上查询，直到根域名服务器。</li></ul></li><li><strong>缓存机制</strong>：<ul><li>为了提高查询效率，DNS 服务器会缓存查询结果。下次查询相同域名时，可以直接从缓存中获取结果，而不需要再次查询上级服务器。</li></ul></li><li><strong>递归查询和迭代查询</strong>：<ul><li><strong>递归查询</strong>：本地域名服务器代表用户向上级服务器查询，直到找到结果。</li><li><strong>迭代查询</strong>：本地域名服务器向上级服务器查询时，上级服务器只返回下一步查询的地址，由本地服务器继续查询。</li></ul></li></ol><h3 id="常见的-dns-服务器"><a class="anchor" href="#常见的-dns-服务器">#</a> 常见的 DNS 服务器</h3><ul><li><strong>公共 DNS 服务器</strong>：如 Google Public DNS（8.8.8.8）、Cloudflare DNS（1.1.1.1）、阿里云 DNS（223.5.5.5）等，提供快速、稳定的域名解析服务。</li><li><strong>本地 DNS 服务器</strong>：由 ISP（互联网服务提供商）或企业内部部署，用于处理本地网络的域名解析请求。</li></ul><h3 id="dns-安全"><a class="anchor" href="#dns-安全">#</a> DNS 安全</h3><ul><li><strong>DNS 劫持</strong>：攻击者通过篡改 DNS 记录，将用户引导到恶意网站。可以通过使用 DNSSEC（DNS Security Extensions）来防止。</li><li><strong>DNS 缓存中毒</strong>：攻击者向 DNS 服务器注入虚假记录，导致用户访问错误的 IP 地址。使用安全的 DNS 服务器和定期清理缓存可以减少风险。</li></ul><h3 id="dns-在面试中的考察"><a class="anchor" href="#dns-在面试中的考察">#</a> DNS 在面试中的考察</h3><p><strong>考察点</strong>：</p><ul><li>是否了解 DNS 的基本概念和工作原理。</li><li>是否了解 DNS 的分层结构和查询过程。</li><li>是否了解常见的 DNS 安全问题及其防护措施。</li></ul><p><strong>回答思路</strong>：</p><ul><li>简要介绍 DNS 的作用和工作原理。</li><li>说明 DNS 的分层结构和查询过程。</li><li>提及常见的 DNS 服务器和其用途。</li><li>讨论 DNS 安全问题及其防护措施。</li></ul></div></details><details class="success"><summary>mysql基本查询方法</summary><div><p><code>SELECT</code> 语句<br>用于从数据库中检索数据。<br>-- 从表中选择所有列<br><code>SELECT * FROM table_name;</code></p><p>-- 从表中选择特定列<br><code>SELECT column1, column2 FROM table_name;</code></p><p><code>WHERE</code> 子句<br>用于根据指定条件过滤数据。<br>-- 选择满足条件的行<br><code>SELECT * FROM table_name WHERE condition;</code></p><p>-- 示例：选择年龄大于 30 的用户<br><code>SELECT * FROM users WHERE age &gt; 30;</code></p><p><code>ORDER BY</code> 子句<br>用于对结果集进行排序。<br>-- 按照指定列升序排序<br><code>SELECT * FROM table_name ORDER BY column1 ASC;</code></p><p>-- 按照指定列降序排序<br><code>SELECT * FROM table_name ORDER BY column1 DESC;</code></p><p><code>LIMIT</code> 子句<br>用于限制返回的行数。<br>-- 选择前 10 行<br><code>SELECT * FROM table_name LIMIT 10;</code></p><p><code>INSERT INTO</code> 语句<br>用于向表中插入新数据。<br>-- 插入一行数据<br><code>INSERT INTO table_name (column1, column2) VALUES (value1, value2);</code></p><p><code>UPDATE</code> 语句<br>用于修改表中的现有数据。<br>-- 更新满足条件的行<br><code>UPDATE table_name SET column1 = value1 WHERE condition;</code></p><p>-- 示例：将所有用户的年龄增加 1<br><code>UPDATE users SET age = age + 1;</code></p><p><code>DELETE</code> 语句<br>用于删除表中的数据。<br>-- 删除满足条件的行<br><code>DELETE FROM table_name WHERE condition;</code></p><p>-- 示例：删除年龄小于 18 的用户<br><code>DELETE FROM users WHERE age &lt; 18;</code></p><p><code>GROUP BY</code> 子句<br>用于将结果集中的行分组，并对每个组进行聚合操作。<br>-- 按照指定列分组<br><code>SELECT column1, COUNT(*) FROM table_name GROUP BY column1;</code></p><p>-- 示例：按年龄分组并统计每个年龄段的用户数量<br><code>SELECT age, COUNT(*) FROM users GROUP BY age;</code></p><p><code>JOIN</code> 操作<br>用于从多个表中检索数据。<br>-- 内连接<br><code>SELECT * FROM table1 INNER JOIN table2 ON table1.column = table2.column;</code></p><p>-- 左连接<br><code>SELECT * FROM table1 LEFT JOIN table2 ON table1.column = table2.column;</code></p><p>-- 右连接<br><code>SELECT * FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;</code></p><p><code>WHERE</code> 与 <code>HAVING</code> 的区别<br><code>WHERE</code> 子句：在分组和聚合之前筛选记录，不能包含聚合函数。<br><code>HAVING</code> 子句：在分组和聚合之后筛选记录，通常包含聚合函数。</p></div></details><details class="success"><summary>HashMap的底层实现</summary><div><p><code>HashMap</code> 是 Java 中常用的数据结构，它的底层实现主要依赖于数组和链表。在 Java 8 及之后的版本中，还引入了红黑树来优化性能。以下是 <code>HashMap</code> 的底层实现细节：</p><h3 id="1-数据存储结构"><a class="anchor" href="#1-数据存储结构">#</a> 1. 数据存储结构</h3><p><code>HashMap</code> 使用一个数组来存储数据，每个数组元素称为一个 “桶”（bucket）。每个桶中存储的是一个链表或红黑树的头节点。</p><h3 id="2-哈希函数"><a class="anchor" href="#2-哈希函数">#</a> 2. 哈希函数</h3><p>当我们向 <code>HashMap</code> 中插入一个键值对时，首先会对键进行哈希运算，得到一个哈希值。然后通过哈希值计算出该键值对应该存储在数组中的哪个位置（即哪个桶中）。计算位置的公式通常是 <code>index = hash % array.length</code> 。</p><h3 id="3-解决哈希冲突"><a class="anchor" href="#3-解决哈希冲突">#</a> 3. 解决哈希冲突</h3><p>哈希冲突是指不同的键经过哈希运算后得到相同的数组索引。 <code>HashMap</code> 通过链表和红黑树来解决哈希冲突：</p><ul><li><strong>链表</strong>：在 Java 8 之前，当发生哈希冲突时， <code>HashMap</code> 会将冲突的键值对存储在同一个桶中的链表中。</li><li><strong>红黑树</strong>：在 Java 8 及之后的版本中，当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，以提高查询效率。</li></ul><h3 id="4-扩容机制"><a class="anchor" href="#4-扩容机制">#</a> 4. 扩容机制</h3><p><code>HashMap</code> 有一个负载因子（默认是 0.75），当 <code>HashMap</code> 中的元素数量超过 <code>容量 * 负载因子</code> 时， <code>HashMap</code> 会进行扩容。扩容时， <code>HashMap</code> 会创建一个新的、更大的数组，并将原数组中的所有元素重新哈希并放入新数组中。</p><h3 id="5-主要方法"><a class="anchor" href="#5-主要方法">#</a> 5. 主要方法</h3><ul><li><code>put(K key, V value)</code> ：将键值对插入 <code>HashMap</code> 中。如果键已经存在，则更新对应的值。</li><li><code>get(Object key)</code> ：根据键获取对应的值。</li><li><code>remove(Object key)</code> ：根据键移除对应的键值对。</li><li><code>containsKey(Object key)</code> ：判断 <code>HashMap</code> 中是否包含指定的键。</li></ul><h3 id="6-示例代码"><a class="anchor" href="#6-示例代码">#</a> 6. 示例代码</h3><p>以下是 <code>HashMap</code> 中节点的实现示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">V</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details><details class="success"><summary>虚拟内存技术</summary><div><p>虚拟内存是计算机系统中的一种内存管理技术，它使得应用程序可以使用比实际物理内存更大的内存空间。虚拟内存通过将物理内存和磁盘存储结合起来，为每个进程提供一个独立的、连续的地址空间。以下是虚拟内存的主要概念和工作原理：</p><h3 id="1-基本概念"><a class="anchor" href="#1-基本概念">#</a> 1. 基本概念</h3><ul><li><strong>虚拟地址空间</strong>：每个进程都有一个独立的虚拟地址空间，这个地址空间是连续的，并且对进程来说是唯一的。</li><li><strong>物理内存</strong>：实际存在的内存硬件，通常是 RAM（随机存取存储器）。</li><li><strong>页面（Page）</strong>：虚拟内存和物理内存都被划分成固定大小的块，称为页面。常见的页面大小是 4KB。</li><li><strong>页表（Page Table）</strong>：操作系统维护的一个数据结构，用于映射虚拟地址到物理地址。</li></ul><h3 id="2-工作原理"><a class="anchor" href="#2-工作原理">#</a> 2. 工作原理</h3><ul><li><strong>地址转换</strong>：当进程访问内存时，CPU 会将虚拟地址转换为物理地址。这个转换过程由内存管理单元（MMU）完成，MMU 使用页表来查找对应的物理地址。</li><li><strong>页面置换</strong>：当物理内存不足时，操作系统会将不常用的页面暂时存储到磁盘上（称为交换空间或页面文件），并将需要的页面加载到物理内存中。这种过程称为页面置换。</li><li><strong>缺页中断</strong>：当进程访问的页面不在物理内存中时，会触发缺页中断。操作系统会处理这个中断，将所需页面从磁盘加载到内存中。</li></ul><h3 id="3-优点"><a class="anchor" href="#3-优点">#</a> 3. 优点</h3><ul><li><strong>扩展内存容量</strong>：虚拟内存使得应用程序可以使用比实际物理内存更大的内存空间。</li><li><strong>内存保护</strong>：每个进程都有独立的虚拟地址空间，防止进程之间的内存访问冲突，提高系统稳定性和安全性。</li><li><strong>内存管理灵活性</strong>：操作系统可以更灵活地管理内存，优化内存使用效率。</li></ul><h3 id="4-示例"><a class="anchor" href="#4-示例">#</a> 4. 示例</h3><p>假设一个系统有 4GB 的物理内存，但通过虚拟内存技术，可以让每个进程使用高达 16GB 的虚拟内存。当一个进程需要访问超过物理内存容量的数据时，操作系统会将不常用的数据页面存储到磁盘上，并将需要的数据页面加载到物理内存中。</p><h3 id="5-实际应用"><a class="anchor" href="#5-实际应用">#</a> 5. 实际应用</h3><p>虚拟内存广泛应用于现代操作系统中，如 Windows、Linux 和 macOS。它使得系统能够运行大型应用程序，并提高系统的稳定性和安全性。</p></div></details><details class="success"><summary>单例模式</summary><div><p>单例模式（Singleton Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。以下是几种常见的单例模式实现方法：</p><h3 id="1-饿汉式eager-initialization"><a class="anchor" href="#1-饿汉式eager-initialization">#</a> 1. 饿汉式（Eager Initialization）</h3><p>在类加载时就创建实例，线程安全，但可能会造成资源浪费。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="2-懒汉式lazy-initialization"><a class="anchor" href="#2-懒汉式lazy-initialization">#</a> 2. 懒汉式（Lazy Initialization）</h3><p>在需要时才创建实例，非线程安全。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="3-线程安全的懒汉式thread-safe-lazy-initialization"><a class="anchor" href="#3-线程安全的懒汉式thread-safe-lazy-initialization">#</a> 3. 线程安全的懒汉式（Thread-Safe Lazy Initialization）</h3><p>使用同步方法确保线程安全，但性能较低。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="4-双重检查锁定double-checked-locking"><a class="anchor" href="#4-双重检查锁定double-checked-locking">#</a> 4. 双重检查锁定（Double-Checked Locking）</h3><p>结合了懒汉式和同步方法的优点，性能较好。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="5-静态内部类bill-pugh-singleton"><a class="anchor" href="#5-静态内部类bill-pugh-singleton">#</a> 5. 静态内部类（Bill Pugh Singleton）</h3><p>利用静态内部类的特性，既实现了延迟加载，又保证了线程安全。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHelper</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">SingletonHelper</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="6-枚举enum-singleton"><a class="anchor" href="#6-枚举enum-singleton">#</a> 6. 枚举（Enum Singleton）</h3><p>枚举类型是实现单例模式的最佳方法，天然支持序列化和线程安全。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 单例方法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-12-12 13:47:58" itemprop="dateModified" datetime="2024-12-12T13:47:58+08:00">2024-12-12</time> </span><span id="项目介绍/" class="item leancloud_visitors" data-flag-title="项目介绍" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="KagurazakaAsahi 微信支付"><p>微信支付</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>KagurazakaAsahi <i class="ic i-at"><em>@</em></i>KA's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://kagurazakaasahi.github.io/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" title="项目介绍">https://kagurazakaasahi.github.io/项目介绍/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s1.imagehub.cc&#x2F;images&#x2F;2023&#x2F;03&#x2F;08&#x2F;e56609b2f9e37e433aec6acc1b07e7e3.jpeg" title="ES搜索的使用"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 学习</span><h3>ES搜索的使用</h3></a></div><div class="item right"><a href="/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s1.imagehub.cc&#x2F;images&#x2F;2023&#x2F;03&#x2F;08&#x2F;8a8fddb54b00933096767cff330e5d82.png" title="使用CDN加速博客访问"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 学习</span><h3>使用CDN加速博客访问</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">项目介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.1.</span> <span class="toc-text">产品定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">产品架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%AB%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">管理端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">用户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">技术选型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">用户层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E5%B1%82"><span class="toc-number">1.3.2.</span> <span class="toc-text">网关层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.3.3.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%82"><span class="toc-number">1.3.4.</span> <span class="toc-text">数据层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">完善登录功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swagger%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">swagger 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5"><span class="toc-number">1.4.3.</span> <span class="toc-text">新增员工</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">存储数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%8C%E5%96%84"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">代码完善</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%95%E5%85%A5%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%B7%B2%E5%AD%98%E5%9C%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%9C%AA%E5%A4%84%E7%90%86"><span class="toc-number">1.4.3.3.1.</span> <span class="toc-text">录入的用户名已存在，抛出异常未处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7id"><span class="toc-number">1.4.3.3.2.</span> <span class="toc-text">动态获取当前登录用户 id</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%98%E5%B7%A5%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">员工分页查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">业务规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">分页查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%8C%E5%96%84-2"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">代码完善</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8%E5%91%98%E5%B7%A5%E8%B4%A6%E5%8F%B7"><span class="toc-number">1.4.5.</span> <span class="toc-text">启用禁用员工账号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">接口设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%91%98%E5%B7%A5"><span class="toc-number">1.4.6.</span> <span class="toc-text">编辑员工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85"><span class="toc-number">1.4.7.</span> <span class="toc-text">公共字段自动填充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81"><span class="toc-number">1.4.8.</span> <span class="toc-text">新增菜品</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">文件上传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.9.</span> <span class="toc-text">菜品分类查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8F%9C%E5%93%81"><span class="toc-number">1.4.10.</span> <span class="toc-text">删除菜品</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81"><span class="toc-number">1.4.11.</span> <span class="toc-text">修改菜品</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%97%E9%93%BA%E8%90%A5%E4%B8%9A%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.12.</span> <span class="toc-text">店铺营业状态设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.12.1.</span> <span class="toc-text">使用技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-number">1.4.12.2.</span> <span class="toc-text">需求分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">1.4.13.</span> <span class="toc-text">微信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.4.13.1.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E5%93%81%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.14.</span> <span class="toc-text">商品与浏览功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">1.4.14.1.</span> <span class="toc-text">接口设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%8F%9C%E5%93%81"><span class="toc-number">1.4.15.</span> <span class="toc-text">缓存菜品</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"><span class="toc-number">1.4.15.1.</span> <span class="toc-text">问题说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.4.15.2.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A5%97%E9%A4%90"><span class="toc-number">1.4.16.</span> <span class="toc-text">缓存套餐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-cache"><span class="toc-number">1.4.16.1.</span> <span class="toc-text">Spring Cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number">1.4.17.</span> <span class="toc-text">添加购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number">1.4.18.</span> <span class="toc-text">查看购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number">1.4.19.</span> <span class="toc-text">清空购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%9C%B0%E5%9D%80%E7%B0%BF"><span class="toc-number">1.4.20.</span> <span class="toc-text">导入地址簿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.20.1.</span> <span class="toc-text">业务功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.4.20.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98"><span class="toc-number">1.4.21.</span> <span class="toc-text">微信支付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E5%AE%9A%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">1.4.22.</span> <span class="toc-text">订单状态定时处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-task"><span class="toc-number">1.4.22.1.</span> <span class="toc-text">Spring Task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cron%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.22.2.</span> <span class="toc-text">cron 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-3"><span class="toc-number">1.4.22.3.</span> <span class="toc-text">需求分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E5%8D%95%E6%8F%90%E9%86%92"><span class="toc-number">1.4.23.</span> <span class="toc-text">来单提醒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket"><span class="toc-number">1.4.23.1.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-4"><span class="toc-number">1.4.23.2.</span> <span class="toc-text">需求分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.4.24.</span> <span class="toc-text">营业额统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#apache-echarts"><span class="toc-number">1.4.24.1.</span> <span class="toc-text">Apache ECharts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.4.25.</span> <span class="toc-text">用户统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.4.26.</span> <span class="toc-text">订单统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E9%87%8F%E6%8E%92%E5%90%8D%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.4.27.</span> <span class="toc-text">销量排名统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8F%B0"><span class="toc-number">1.4.28.</span> <span class="toc-text">工作台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%BF%90%E8%90%A5%E6%95%B0%E6%8D%AEexcel%E6%8A%A5%E8%A1%A8"><span class="toc-number">1.4.29.</span> <span class="toc-text">导出运营数据 Excel 报表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#apache-poi"><span class="toc-number">1.4.29.1.</span> <span class="toc-text">Apache POI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-5"><span class="toc-number">1.4.29.2.</span> <span class="toc-text">需求分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AE%E7%82%B9%E9%9A%BE%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">亮点难点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">Nginx 反向代理和负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8jwt"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用 JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">高并发处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.</span> <span class="toc-text">细节补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">实现功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%AB%AF-2"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">管理端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AB%AF-2"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">用户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">细节问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">为什么要加拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.5.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.6.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.6.7.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.8.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.9.</span> <span class="toc-text">进程与线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.10.</span> <span class="toc-text">实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.11.</span> <span class="toc-text">DNS 服务器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-dns-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.6.12.</span> <span class="toc-text">常见的 DNS 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.13.</span> <span class="toc-text">DNS 安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E8%80%83%E5%AF%9F"><span class="toc-number">1.6.14.</span> <span class="toc-text">DNS 在面试中的考察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.15.</span> <span class="toc-text">1. 数据存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.16.</span> <span class="toc-text">2. 哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.6.17.</span> <span class="toc-text">3. 解决哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.18.</span> <span class="toc-text">4. 扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.19.</span> <span class="toc-text">5. 主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.20.</span> <span class="toc-text">6. 示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.21.</span> <span class="toc-text">1. 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.22.</span> <span class="toc-text">2. 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9"><span class="toc-number">1.6.23.</span> <span class="toc-text">3. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.24.</span> <span class="toc-text">4. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.25.</span> <span class="toc-text">5. 实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8Feager-initialization"><span class="toc-number">1.6.26.</span> <span class="toc-text">1. 饿汉式（Eager Initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%87%92%E6%B1%89%E5%BC%8Flazy-initialization"><span class="toc-number">1.6.27.</span> <span class="toc-text">2. 懒汉式（Lazy Initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8Fthread-safe-lazy-initialization"><span class="toc-number">1.6.28.</span> <span class="toc-text">3. 线程安全的懒汉式（Thread-Safe Lazy Initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9Adouble-checked-locking"><span class="toc-number">1.6.29.</span> <span class="toc-text">4. 双重检查锁定（Double-Checked Locking）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BBbill-pugh-singleton"><span class="toc-number">1.6.30.</span> <span class="toc-text">5. 静态内部类（Bill Pugh Singleton）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9E%9A%E4%B8%BEenum-singleton"><span class="toc-number">1.6.31.</span> <span class="toc-text">6. 枚举（Enum Singleton）</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023-02-04-%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%E8%BE%93%E5%85%A5/" rel="bookmark" title="可理解性输入">可理解性输入</a></li><li><a href="/Git%E4%BD%BF%E7%94%A8/" rel="bookmark" title="Git及Github使用">Git及Github使用</a></li><li><a href="/SD%E8%BF%9B%E9%98%B62-prompt%E9%80%89%E5%8F%96/" rel="bookmark" title="SD进阶1-prompt选取">SD进阶1-prompt选取</a></li><li><a href="/3.4/" rel="bookmark" title="3.4">3.4</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--mysql/" rel="bookmark" title="八股文概要--Mysql">八股文概要--Mysql</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--SpringBoot/" rel="bookmark" title="八股文概要--SpringBoot">八股文概要--SpringBoot</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Redis/" rel="bookmark" title="八股文概要--Redis">八股文概要--Redis</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Spring/" rel="bookmark" title="八股文概要--Spring">八股文概要--Spring</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="bookmark" title="八股文概要--线程池">八股文概要--线程池</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--MyBatis/" rel="bookmark" title="八股文概要--MyBatis">八股文概要--MyBatis</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--HashMap/" rel="bookmark" title="八股文概要--HashMap">八股文概要--HashMap</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Thread/" rel="bookmark" title="八股文概要--Thread">八股文概要--Thread</a></li><li><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--JVM/" rel="bookmark" title="八股文概要--JVM">八股文概要--JVM</a></li><li><a href="/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="bookmark" title="单元测试">单元测试</a></li><li><a href="/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="bookmark" title="ES搜索的使用">ES搜索的使用</a></li><li class="active"><a href="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" rel="bookmark" title="项目介绍">项目介绍</a></li><li><a href="/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/" rel="bookmark" title="使用CDN加速博客访问">使用CDN加速博客访问</a></li><li><a href="/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="bookmark" title="单片机">单片机</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="KagurazakaAsahi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">KagurazakaAsahi</p><div class="description" itemprop="description">欢迎来到咖酱的Blog~~🌸</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">55</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thZ3VyYXpha2FBc2FoaQ==" title="https:&#x2F;&#x2F;github.com&#x2F;KagurazakaAsahi"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ3ODg2Mjk0MA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;478862940"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE4MDU1Njk2ODVAcXEuY29t" title="mailto:1805569685@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNTI2Mjk0NDk=" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;52629449"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-star"></i>关于</a><ul class="submenu"><li class="item"><a href="/me/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/web/" rel="section"><i class="ic i-cloud"></i>网站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/hitokoto/" rel="section"><i class="ic i-comments"></i>一言</a></li><li class="item"><a href="/gallery/" rel="section"><i class="ic i-chart-area"></i>画廊</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/study/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/study/%E7%BC%96%E7%A8%8B/" title="分类于 编程">编程</a></div><span><a href="/Git%E4%BD%BF%E7%94%A8/" title="Git及Github使用">Git及Github使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/study/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/study/JAVA%E5%85%AB%E8%82%A1%E6%96%87/" title="分类于 JAVA八股文">JAVA八股文</a></div><span><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Spring/" title="八股文概要--Spring">八股文概要--Spring</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/3.16/" title="3.16">3.16</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/talk/" title="分类于 杂谈">杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/talk/acg/" title="分类于 ACG">ACG</a></div><span><a href="/%E6%9C%AC%E5%9C%B0%E5%8A%A8%E7%94%BB%E8%A7%82%E8%B5%8F%E6%8C%87%E5%8C%97/" title="本地动画观赏指北">本地动画观赏指北</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023-11-11-%E5%A4%9A%E5%B1%8F%E5%8D%8F%E5%90%8C/" title="多屏协同">多屏协同</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/talk/" title="分类于 杂谈">杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/talk/blog/" title="分类于 博客">博客</a></div><span><a href="/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E6%97%B6%E6%89%93%E5%BC%80%E6%96%87%E7%AB%A0/" title="hexo命令创建文章同时时打开文章">hexo命令创建文章同时时打开文章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/share/" title="分类于 分享">分享</a> <i class="ic i-angle-right"></i> <a href="/categories/share/softwore/" title="分类于 软件">软件</a></div><span><a href="/2023-02-06-%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9/" title="输入法的选择">输入法的选择</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/study/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/study/JAVA%E5%85%AB%E8%82%A1%E6%96%87/" title="分类于 JAVA八股文">JAVA八股文</a></div><span><a href="/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--mysql/" title="八股文概要--Mysql">八股文概要--Mysql</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/daily/" title="分类于 日常">日常</a></div><span><a href="/HC550/" title="洗牙&amp;HC550">洗牙&HC550</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/study/" title="分类于 学习">学习</a></div><span><a href="/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" title="项目介绍">项目介绍</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">KagurazakaAsahi @ 咖酱の博客</span></div><script>fetch('https://v1.hitokoto.cn/?c=a&c=b')
      .then(response => response.json())
      .then(data => {
        const hitokoto = document.querySelector('#hitokoto_text')
        hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`
        hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script><div class="count"><p id="hitokoto"><a href="#" id="hitokoto_text">:D 获取中...</a></p><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">98k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:29</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>次</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>强劲驱动</div></div></div></footer></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script>function createtime(){var n=new Date("02/01/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),60==snum&&(snum=0),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><script data-config type="text/javascript">var LOCAL={path:"项目介绍/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->