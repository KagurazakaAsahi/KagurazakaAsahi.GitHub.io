{
    "version": "https://jsonfeed.org/version/1",
    "title": "KA's Blog",
    "subtitle": "等待,并心怀希望吧",
    "icon": "https://kagurazakaasahi.github.io/images/favicon.ico",
    "description": "欢迎来到咖酱的Blog~~🌸",
    "home_page_url": "https://kagurazakaasahi.github.io",
    "items": [
        {
            "id": "https://kagurazakaasahi.github.io/%E5%8D%95%E7%89%87%E6%9C%BA/",
            "url": "https://kagurazakaasahi.github.io/%E5%8D%95%E7%89%87%E6%9C%BA/",
            "title": "单片机",
            "date_published": "2024-12-12T05:47:58.869Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1\"><a class=\"anchor\" href=\"#1\">#</a> 1</h2>\n<p>求 1+2+3+…+99 的 BCD 和，存入 RAM 高 128B 区域</p>\n<pre><code class=\"language-assembly\">ORG 0000H\nLJMP START\n\nORG 0100H\nSTART:\n    MOV R2, #01H          ; 初始化计数器R2为1\n    MOV R3, #99H          ; 循环99次\n    MOV A, #00H           ; 初始化累加器A为0\n    MOV B, #00H           ; 初始化寄存器B为0，用于进位\n\nLOOP:\n    ADD A, R2             ; 将R2中的值加到累加器A中\n    INC R2                ; 计数器R2加1\n    DJNZ R3, LOOP         ; 减1非0转移进行循环\n\n    ; 现在A中包含1到99的和\n    MOV B, A              ; 将累加结果存入B\n    MOV A, #00H           ; 清空累加器A\n\n    ; 转换为BCD码\n    MOV A, B              ; 将累加结果存入A\n    DA A                  ; BCD码调整\n    MOV R4, A             ; 将调整后的BCD码存入R4\n\n    ; 存储结果到RAM高128B区域\n    MOV R0, #80H          ; 设置RAM地址\n    MOV A, R4\n    MOV @R0, A            ; 存储结果\n\n    SJMP $                ; 无限循环，终止程序\n\nEND\n</code></pre>\n<h2 id=\"2\"><a class=\"anchor\" href=\"#2\">#</a> 2</h2>\n<p>使用外部中断 0 和外部中断 1，在动态数码管上显示中断 0 次数，中断 1 用作次数清 0。数码管采用 74HC595 驱动。中断次数显示形式自定（3 位十进制或 2 位 16 进制）</p>\n<pre><code class=\"language-assembly\">ORG  0000H\t\t\n\t   LJMP\tMain\n\t   ORG \t0003H\t        ; 外部中断0向量地址\n\t   LJMP\tINT0_ISR    \n\t  ORG \t0033H\t        ; 外部中断1向量地址\n\t   LJMP\tINT1_ISR  \n\t   ORG\t 0100H\t\nMain:  SETB  EX0           ; 外部中断0允许\n       SETB  IT0           ; 外部中断0下降沿触发\n       SETB  EX1           ; 外部中断1允许\n       SETB  IT1           ; 外部中断1下降沿触发\nLoop:   DispScan;\n       SJMP  Loop\n       \n       INT0_ISR:\n       INC   CNT          ; CNT加1\n       RETI               ; 返回主程序\n       INT1_ISR:\n       MOV CNT, #0         ; CNT清零\n       RETI               ; 返回主程序\nDispScan: MOV\tA, CNT\n\t              MOV\tB, #10\n\t              DIV  \tAB\n\t              MOV\tR5, A    ;R5存百位\n\t              MOV\tA, #10\n\t              XCH          A, B\n\t              DIV  \tAB\n\t              MOV\tR6, A    ; R6存十位 \n\t             MOV\tR7, B    ; R7存个位\n            MOV  P1，#0FEH        ;选中最右边数码管\n\t        MOV\tDPTR, #T_Disp ; 7段码表头\n\t        MOV\tA, R7                  ; 待显示的个位数\n             MOVC\tA, @A+DPTR\n             MOV   P0， A\n             MOV  P1，#0FDH        ;选中最右边第2数码管\n\t       MOV\tA, R6                  ; 待显示的十位数\n             MOVC\tA, @A+DPTR\n             MOV   P0， A\n             MOV   P1，#0FBH        ;选中最右边第3数码管\n\t       MOV\tA, R5                  ; 待显示的百位数\n             MOVC\tA, @A+DPTR\n             MOV   P0， A\nT_Disp: DB 3FH,06H,5BH,4FH,66H,6DH, 7DH,07H\n              DB  7FH,6FH,77H,7CH,39H,5EH,79H,71H; 0-F的7段码 \n</code></pre>\n<h2 id=\"3\"><a class=\"anchor\" href=\"#3\">#</a> 3</h2>\n<p>定时器 0/1 做 16 位自动重装，使 P1.7 输出周期为 1 秒或 2 秒的矩形波，占空比自定。</p>\n<pre><code class=\"language-assembly\">ORG 0000H\nLJMP MAIN\n\n; 定义单片机寄存器\nP1      EQU     90H\nTMOD    EQU     89H\nTH0     EQU     8CH\nTL0     EQU     8AH\nTCON    EQU     88H\n\n; 定义常量\nTIMER0_MODE EQU 00000001B ; 定时器0模式1（16位定时器）\nTIMER0_START EQU 00000001B ; 启动定时器0\nTIMER0_STOP  EQU 00000000B ; 停止定时器0\n\n; 初始化定时器0\nINIT_TIMER0:\n    MOV TMOD, TIMER0_MODE ; 设置定时器0为模式1\n    MOV TH0, #0FCH        ; 高8位初值\n    MOV TL0, #18H         ; 低8位初值\n    SETB TR0              ; 启动定时器0\n    RET\n\n; 定时器0中断服务程序\nTIMER0_ISR:\n    CLR TR0               ; 停止定时器0\n    CPL P1.7              ; 翻转P1.7引脚状态\n    MOV TH0, #0FCH        ; 重新加载高8位初值\n    MOV TL0, #18H         ; 重新加载低8位初值\n    SETB TR0              ; 重新启动定时器0\n    RETI\n\n; 主程序\nMAIN:\n    MOV P1, #00H          ; 初始化P1口\n    CALL INIT_TIMER0      ; 初始化定时器0\n    SETB EA               ; 开启全局中断\n    SETB ET0              ; 开启定时器0中断\n    SJMP $                ; 无限循环\n\nEND\n</code></pre>\n",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/",
            "url": "https://kagurazakaasahi.github.io/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/",
            "title": "使用CDN加速博客访问",
            "date_published": "2024-09-02T04:00:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>由于众所周知的原因，国内访问 <code>Github pages</code>  较慢，十分影响博客访问体验</p>\n<p>不过好在 <code>CDN</code>  技术可以很好的缓解这个问题</p>\n<details class=\"success\"><summary>什么是CDN</summary><div>\n<p>CDN，全称为内容分发网络（Content Delivery Network），是一种通过在全球各地部署的服务器来缓存和分发内容的技术。其主要目的是加速用户访问速度、提高网站可用性和降低带宽成本。以下是 CDN 的主要功能和优势：</p>\n<p>主要功能<br />\n内容缓存：<br />\nCDN 会将网站的静态资源（如图片、视频、CSS、JavaScript 文件等）缓存到离用户最近的服务器上。当用户请求这些资源时，可以从最近的服务器获取，而不需要每次都从源服务器获取。<br />\n负载均衡：<br />\n通过智能调度和负载均衡，CDN 可以将用户请求分配到不同的服务器上，避免单个服务器过载，提高整体性能。<br />\n内容分发：<br />\nCDN 通过分布在全球的多个节点，将内容分发到离用户最近的服务器上，减少网络延迟，提高访问速度。<br />\n优势<br />\n提高访问速度：<br />\n由于内容被缓存到离用户最近的服务器上，用户可以更快地获取所需资源，减少页面加载时间。<br />\n降低带宽成本：<br />\n通过缓存和优化，CDN 可以减少源服务器的带宽消耗，从而降低网站的托管成本。<br />\n提高可用性和稳定性：<br />\nCDN 可以处理更多的 Web 流量，减少源服务器的负载。如果某个节点出现故障，其他节点可以继续提供服务，确保网站的高可用性。<br />\n增强安全性：<br />\nCDN 可以帮助抵御分布式拒绝服务（DDoS）攻击，通过分散流量减少对源服务器的影响。<br />\n示例<br />\n假设你在北京访问一个美国的网站，如果没有 CDN，数据需要从美国的服务器传输到北京，可能会有较大的延迟。而使用 CDN 后，数据可以从北京的 CDN 节点获取，大大减少了传输时间，提高了访问速度。</p>\n</div></details>\n<p>那么如何使用 CDN 加速网站呢</p>\n<h2 id=\"使用cloudflare\"><a class=\"anchor\" href=\"#使用cloudflare\">#</a> 使用 Cloudflare</h2>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902122055522.png\" class=\"\" title=\"image-20240902122055522\"></p>\n<p>注册登录 <code>Cloudflare</code> , 找到 <code>Website</code> , 添加你的网站域名，比如我的就是 <code>kablog.top</code></p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902122216099.png\" class=\"\" title=\"image-20240902122216099\"></p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902122410445.png\" class=\"\" title=\"image-20240902122410445\"></p>\n<p>然后选 <code>free</code>  即可，白嫖党大胜利！</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902122527680.png\" class=\"\" title=\"image-20240902122527680\"></p>\n<p>然后添加记录</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902122640946.png\" class=\"\" title=\"image-20240902122640946\"></p>\n<p>参数类似上述，将 <code>Name</code>  的 <code>kablog.top</code>  改为你的域名即可</p>\n<pre><code>185.199.108.153\n185.199.109.153\n185.199.110.153\n185.199.111.153\n2606:50c0:8000::153\n2606:50c0:8001::153\n2606:50c0:8002::153\n2606:50c0:8003::153\n</code></pre>\n<p><img data-src=\"https://pic.qinyu.space/image/image-20231204230559749.png\" alt=\"image-20231204230559749\" /></p>\n<p>然后即可获得上述的 DNS 服务器</p>\n<h2 id=\"修改域名dns服务器\"><a class=\"anchor\" href=\"#修改域名dns服务器\">#</a> 修改域名 DNS 服务器</h2>\n<p>找到你的域名供应商，我这里以阿里云为例</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902123244771.png\" class=\"\" title=\"image-20240902123244771\"></p>\n<p>域名列表 -&gt; 管理</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902123340147.png\" class=\"\" title=\"image-20240902123340147\"></p>\n<p>修改你的 DNS 服务器为上述</p>\n<p>等待几小时同步后就完成了</p>\n<h2 id=\"问题解决\"><a class=\"anchor\" href=\"#问题解决\">#</a> 问题解决</h2>\n<p>当使用  <code>Cloudflare</code>  的 <code>DNS</code>  服务器和 <code>CDN</code>  加速时，出现 “重定向次数过多” 的问题通常是由于  <code>SSL/TLS</code>  设置不匹配导致的。</p>\n<p>具体设置如下:</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902123859454.png\" class=\"\" title=\"image-20240902123859454\"></p>\n<p>找到自己的网站</p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902123932939.png\" class=\"\" title=\"image-20240902123932939\"></p>\n<p>找到 <code>SSL/TLS</code></p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902124009509.png\" class=\"\" title=\"image-20240902124009509\"></p>\n<p><img data-src=\"/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE/image-20240902124036872.png\" class=\"\" title=\"image-20240902124036872\"></p>\n<p>使用 <code>Full</code>  和 <code>Full(Strict)</code>  均可</p>\n<h2 id=\"结论\"><a class=\"anchor\" href=\"#结论\">#</a> 结论</h2>\n<p>使用 <code>CDN</code>  加速后访问网站速度明显提升，更加流畅了</p>\n",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/",
            "url": "https://kagurazakaasahi.github.io/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/",
            "title": "项目介绍",
            "date_published": "2024-09-01T09:30:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"项目介绍\"><a class=\"anchor\" href=\"#项目介绍\">#</a> 项目介绍</h1>\n<h2 id=\"产品定位\"><a class=\"anchor\" href=\"#产品定位\">#</a> 产品定位</h2>\n<p>为餐饮企业定制的一款软件产品</p>\n<h2 id=\"产品架构\"><a class=\"anchor\" href=\"#产品架构\">#</a> 产品架构</h2>\n<h3 id=\"管理端\"><a class=\"anchor\" href=\"#管理端\">#</a> 管理端</h3>\n<ul>\n<li>员工管理</li>\n<li>分类管理</li>\n<li>菜品管理</li>\n<li>套餐管理</li>\n<li>订单管理</li>\n<li>工作台</li>\n<li>数据统计</li>\n<li>来单提醒</li>\n</ul>\n<h3 id=\"用户端\"><a class=\"anchor\" href=\"#用户端\">#</a> 用户端</h3>\n<ul>\n<li>微信登录</li>\n<li>商品浏览</li>\n<li>购物车</li>\n<li>用户下单</li>\n<li>微信支付</li>\n<li>历史订单</li>\n<li>地址管理</li>\n<li>用户催单</li>\n</ul>\n<h2 id=\"技术选型\"><a class=\"anchor\" href=\"#技术选型\">#</a> 技术选型</h2>\n<h3 id=\"用户层\"><a class=\"anchor\" href=\"#用户层\">#</a> 用户层</h3>\n<ul>\n<li>node.js</li>\n<li>VUE.js</li>\n<li>ElementUI</li>\n<li>微信小程序</li>\n<li>apache echarts</li>\n</ul>\n<h3 id=\"网关层\"><a class=\"anchor\" href=\"#网关层\">#</a> 网关层</h3>\n<ul>\n<li>Nginx</li>\n</ul>\n<h3 id=\"应用层\"><a class=\"anchor\" href=\"#应用层\">#</a> 应用层</h3>\n<ul>\n<li>Spring Boot</li>\n<li>Spring MVC</li>\n<li>Spring Task</li>\n<li>httpclient</li>\n<li>Spring Cache</li>\n<li>JWT</li>\n<li>阿里云 OSS</li>\n<li>Swagger</li>\n<li>POI</li>\n<li>WebSocket</li>\n</ul>\n<h3 id=\"数据层\"><a class=\"anchor\" href=\"#数据层\">#</a> 数据层</h3>\n<ul>\n<li>MySQL</li>\n<li>Redis</li>\n<li>mybatis</li>\n<li>pagehelper</li>\n<li>spring data redis</li>\n</ul>\n<h2 id=\"具体实现\"><a class=\"anchor\" href=\"#具体实现\">#</a> 具体实现</h2>\n<h3 id=\"完善登录功能\"><a class=\"anchor\" href=\"#完善登录功能\">#</a> 完善登录功能</h3>\n<ol>\n<li>修改数据库中的密码，改为 MD5 加密后的密文</li>\n<li>修改 JAVA 代码，前端提交的密码进行 MD5 加密后再跟数据库中的密码对比</li>\n<li>抛异常使用消息常量类</li>\n</ol>\n<h3 id=\"swagger的使用\"><a class=\"anchor\" href=\"#swagger的使用\">#</a> swagger 的使用</h3>\n<p>swagger 可以方便的进行前后端联调，由于该项目仅涉及两位成员且沟通方便故未使用，仅学习了解过如何使用</p>\n<h3 id=\"新增员工\"><a class=\"anchor\" href=\"#新增员工\">#</a> 新增员工</h3>\n<p>前端提交的数据与实体类差别较大，故采用 DTO 来封装数据</p>\n<p>实体类（Entity）<br />\n与数据库表对应：实体类通常直接映射到数据库表，包含所有字段，便于持久化操作。<br />\n封装业务逻辑：实体类不仅仅是数据的载体，还可以包含业务逻辑和数据状态。<br />\n简化数据库操作：通过 ORM 框架（如 Hibernate），实体类可以简化数据库的增删改查操作。<br />\nDTO（数据传输对象）<br />\n数据传输优化：DTO 主要用于在不同层（如控制层和服务层）之间传输数据。它可以只包含需要传输的字段，减少不必要的数据传输，提高性能。<br />\n安全性：通过 DTO，可以避免直接暴露实体类中的敏感数据，增强系统的安全性。<br />\n解耦前后端：DTO 可以根据前端需求定制，避免前端直接依赖实体类，从而实现前后端的解耦。<br />\n简化数据转换：在复杂业务场景中，DTO 可以简化数据转换逻辑，避免在多个地方重复编写转换代码。<br />\n使用场景<br />\n实体类：适用于需要直接与数据库交互的场景，如 DAO 层。<br />\nDTO：适用于需要在不同层之间传输数据的场景，如控制层与服务层之间的数据传输。</p>\n<h4 id=\"存储数据\"><a class=\"anchor\" href=\"#存储数据\">#</a> 存储数据</h4>\n<p>无须逐个设置实体对象属性，而是使用对象属性拷贝 ( <code>BeanUtils.copyProperties</code> ), 再设置其他 DTO 中不存在的属性</p>\n<h4 id=\"插入数据\"><a class=\"anchor\" href=\"#插入数据\">#</a> 插入数据</h4>\n<pre><code class=\"language-Java\">@Insert(&quot;insert into employee(name, username, password, phone) values(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;)&quot;)\nvoid insert(Employee employee)\n</code></pre>\n<details class=\"success\"><summary></summary><div>\n<p>MyBatis 提供了多种注解来简化 SQL 操作，避免了繁琐的 XML 配置。以下是一些常用的 MyBatis 注解及其用途：</p>\n<p>常用注解</p>\n<pre><code class=\"language-Java\">@Select：用于执行查询操作。\n@Select(&quot;SELECT * FROM employee WHERE id = #&#123;id&#125;&quot;)\nEmployee selectById(int id);\n\n@Insert：用于执行插入操作。\n@Insert(&quot;INSERT INTO employee(name, username, password, phone) VALUES(#&#123;name&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;phone&#125;)&quot;)\nvoid insert(Employee employee);\n\n@Update：用于执行更新操作。\n@Update(&quot;UPDATE employee SET name = #&#123;name&#125;, username = #&#123;username&#125;, password = #&#123;password&#125;, phone = #&#123;phone&#125; WHERE id = #&#123;id&#125;&quot;)\nvoid update(Employee employee);\n\n@Delete：用于执行删除操作。\n@Delete(&quot;DELETE FROM employee WHERE id = #&#123;id&#125;&quot;)\nvoid delete(int id);\n\n@Results 和 @Result：用于映射查询结果到对象属性。\n@Select(&quot;SELECT * FROM employee WHERE id = #&#123;id&#125;&quot;)\n@Results(&#123;\n    @Result(property = &quot;id&quot;, column = &quot;id&quot;),\n    @Result(property = &quot;name&quot;, column = &quot;name&quot;),\n    @Result(property = &quot;username&quot;, column = &quot;username&quot;),\n    @Result(property = &quot;password&quot;, column = &quot;password&quot;),\n    @Result(property = &quot;phone&quot;, column = &quot;phone&quot;)\n&#125;)\nEmployee selectById(int id);\n\n@One 和 @Many：用于一对一和一对多的关系映射。\n@Select(&quot;SELECT * FROM department WHERE id = #&#123;id&#125;&quot;)\n@Results(&#123;\n    @Result(property = &quot;id&quot;, column = &quot;id&quot;),\n    @Result(property = &quot;name&quot;, column = &quot;name&quot;),\n    @Result(property = &quot;employees&quot;, column = &quot;id&quot;, \n            many = @Many(select = &quot;selectEmployeesByDepartmentId&quot;))\n&#125;)\nDepartment selectById(int id);\n</code></pre>\n</div></details>\n<h4 id=\"代码完善\"><a class=\"anchor\" href=\"#代码完善\">#</a> 代码完善</h4>\n<h5 id=\"录入的用户名已存在抛出异常未处理\"><a class=\"anchor\" href=\"#录入的用户名已存在抛出异常未处理\">#</a> 录入的用户名已存在，抛出异常未处理</h5>\n<p>添加异常处理即可。</p>\n<h5 id=\"动态获取当前登录用户id\"><a class=\"anchor\" href=\"#动态获取当前登录用户id\">#</a> 动态获取当前登录用户 id</h5>\n<p>这里我们使用 JWT 技术。</p>\n<p>通过拦截器将 Token 令牌拦截，解析出用户 id，传给 save 方法。</p>\n<p>但是拦截器中并未直接调用 save 方法，那么该如何将解析到的用户 id 传给 save 方法呢？</p>\n<p>这里我们采用 ThreadLocal。</p>\n<details class=\"success\"><summary>ThreadLocal</summary><div>\n<p><code>ThreadLocal</code>  并不是一个 Thread, 而是 Thread 的局部变量。</p>\n<p><code>ThreadLocal</code>  为每个线程提供单独一份存储空间，具有线程隔离的效果，只有线程内才能获取到对应的值，线程外则不能访问。</p>\n</div></details>\n<p>通过观察 <code>ThreadId</code>  很容易发现，每一次请求都是一个线程，故可以封装上述 <code>ThreadLocal</code> , 添加 <code>setId</code> , <code>getId</code> , <code>removeId</code>  方法成一个工具类 BaseContext、</p>\n<p>因此，在拦截器中将 Id 存入 <code>ThreadLocal</code>  然后在 save 方法中取出即可。</p>\n<h3 id=\"员工分页查询\"><a class=\"anchor\" href=\"#员工分页查询\">#</a> 员工分页查询</h3>\n<h4 id=\"业务规则\"><a class=\"anchor\" href=\"#业务规则\">#</a> 业务规则</h4>\n<ul>\n<li>根据页码展示员工信息</li>\n<li>每页展示 10 条数据</li>\n<li>分页查询时可以根据需要，输入员工的姓名进行查询</li>\n</ul>\n<h4 id=\"接口设计\"><a class=\"anchor\" href=\"#接口设计\">#</a> 接口设计</h4>\n<ul>\n<li>路径：</li>\n<li>请求方法：GET</li>\n<li>请求参数： <code>name</code> ， <code>page</code> ， <code>pagesize</code></li>\n</ul>\n<h4 id=\"分页查询\"><a class=\"anchor\" href=\"#分页查询\">#</a> 分页查询</h4>\n<p>一般是通过基于 <code>SQL</code>  的 <code>limit</code>  关键字进行分页查询，如:</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> employee <span class=\"token keyword\">limit</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span></pre></td></tr></table></figure><p>但是我们也可以使用分页查询插件，这里我使用的是 <code>pagehelper</code> , 它基于拦截器动态拼接字符串</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">PageHelper</span><span class=\"token punctuation\">.</span><span class=\"token function\">startPage</span><span class=\"token punctuation\">(</span>employeePageQueryDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>employeePageQueryDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getPageSzie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Page</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>employee<span class=\"token punctuation\">></span></span> <span class=\"token class-name\">Page</span> <span class=\"token operator\">=</span> employeeMapper<span class=\"token punctuation\">.</span><span class=\"token function\">pageQuery</span><span class=\"token punctuation\">(</span>employeePageQueryDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>查询是模糊查询不是等值查询，故使用 <code>like</code></p>\n<h4 id=\"代码完善-2\"><a class=\"anchor\" href=\"#代码完善-2\">#</a> 代码完善</h4>\n<p>经测试，上述编写的代码存在数据格式的问题需要解决</p>\n<ul>\n<li>\n<p>方式一：在属性上加入注解，对日期进行格式化</p>\n<pre><code class=\"language-Java\">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)\nprivate LocalDateTime updateTime;\n</code></pre>\n<p>但上述方式只能对单一方法进行格式化，故推荐使用方式二统一格式化</p>\n</li>\n<li>\n<p>方式二：在 <code>WebMvcConfiguration</code>  中扩展 <code>SpringMVC</code>  的消息转换器，统一对日期类型进行格式化处理</p>\n<pre><code class=\"language-Java\">protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)&#123;\n    log.warning(&quot;开始扩展消息转换器...&quot;);\n    //创建一个消息转化器对象\n    MappingJackson2HttpmessageConverter converter = new MappingJackson2HttpMessageConverter();\n    //设置对象转换器,可以将Java对象转为json字符串\n    converter.setObjectmapper(new JacksonObjectMapper());\n    //将我们自己的转换器放入spring MVC框架的容器中\n    converters.add(0,converter);\n&#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"启用禁用员工账号\"><a class=\"anchor\" href=\"#启用禁用员工账号\">#</a> 启用禁用员工账号</h3>\n<h4 id=\"接口设计-2\"><a class=\"anchor\" href=\"#接口设计-2\">#</a> 接口设计</h4>\n<ul>\n<li>路径</li>\n<li>请求方式：POST</li>\n<li>请求参数：\n<ul>\n<li>Headers： <code>contentType</code></li>\n<li>路径参数: <code>status</code></li>\n<li>Query: <code>id</code></li>\n</ul>\n</li>\n<li>返回数据: <code>code</code> , <code>msg</code> , <code>data</code></li>\n</ul>\n<h3 id=\"编辑员工\"><a class=\"anchor\" href=\"#编辑员工\">#</a> 编辑员工</h3>\n<h3 id=\"公共字段自动填充\"><a class=\"anchor\" href=\"#公共字段自动填充\">#</a> 公共字段自动填充</h3>\n<h4 id=\"问题分析\"><a class=\"anchor\" href=\"#问题分析\">#</a> 问题分析</h4>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240831172556784.png\" class=\"\" title=\"image-20240831172556784\"></p>\n<p>业务表中有公共字段，逐个赋值非常麻烦，之后也难以修改，不便于后期维护</p>\n<p>那么如何解决呢？</p>\n<ul>\n<li>自定义注解 AutoFill, 用于标识需要进行公共字段自动填充的方法</li>\n<li>自定义切面类 AutoFillAspect, 统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</li>\n<li>在 Mapper 方法上加入 AutoFill 注解</li>\n</ul>\n<p>技术点：枚举，注解，AOP, 反射</p>\n<h3 id=\"新增菜品\"><a class=\"anchor\" href=\"#新增菜品\">#</a> 新增菜品</h3>\n<h4 id=\"需求分析\"><a class=\"anchor\" href=\"#需求分析\">#</a> 需求分析</h4>\n<ul>\n<li>菜品必须是唯一的</li>\n<li>菜品必须在某个分类下，不能单独存在</li>\n<li>新增菜品时可根据情况选择菜品的口味</li>\n<li>每个菜品必须对应一张图片</li>\n</ul>\n<h4 id=\"接口设计-3\"><a class=\"anchor\" href=\"#接口设计-3\">#</a> 接口设计</h4>\n<ul>\n<li>根据类型查询分类 (已完成)</li>\n<li>文件上传</li>\n<li>新增菜品</li>\n</ul>\n<h4 id=\"文件上传\"><a class=\"anchor\" href=\"#文件上传\">#</a> 文件上传</h4>\n<p>使用阿里云 oss 存储上传的二进制文件</p>\n<p>使用 UUID 来重命名，防止出现重名的情况</p>\n<p>新增菜品和口味时涉及两张表的操作</p>\n<p>涉及多张表 -&gt; 保证事务一致性 -&gt; 添加注解 <code>@Transactional</code></p>\n<h3 id=\"菜品分类查询\"><a class=\"anchor\" href=\"#菜品分类查询\">#</a> 菜品分类查询</h3>\n<h3 id=\"删除菜品\"><a class=\"anchor\" href=\"#删除菜品\">#</a> 删除菜品</h3>\n<p>这里需要注意的是，如果菜品属于某一套餐，则不可随意删除，需要对菜品 - 口味关联表进行操作</p>\n<h3 id=\"修改菜品\"><a class=\"anchor\" href=\"#修改菜品\">#</a> 修改菜品</h3>\n<h4 id=\"接口设计-4\"><a class=\"anchor\" href=\"#接口设计-4\">#</a> 接口设计</h4>\n<ul>\n<li>根据 id 查询菜品</li>\n<li>根据类型查询分类 (已实现)</li>\n<li>文件上传 (已实现)</li>\n<li>修改菜品</li>\n</ul>\n<h4 id=\"具体实现-2\"><a class=\"anchor\" href=\"#具体实现-2\">#</a> 具体实现</h4>\n<p>修改操作在技术层面上转化为先删除，再重新插入新的数据</p>\n<h3 id=\"店铺营业状态设置\"><a class=\"anchor\" href=\"#店铺营业状态设置\">#</a> 店铺营业状态设置</h3>\n<h4 id=\"使用技术\"><a class=\"anchor\" href=\"#使用技术\">#</a> 使用技术</h4>\n<p>使用 <code>Spring Data Redis</code>  再 JAVA 中操作 <code>Redis</code></p>\n<ol>\n<li>导入 <code>Spring Data Redis</code>  的 <code>maven</code>  坐标</li>\n<li>配置 <code>Redis</code>  数据源</li>\n<li>编写配置类，\t创建 <code>RedisTemple</code>  对象</li>\n<li>通过 <code>RedisTemple</code>  对象操作 <code>Redis</code></li>\n</ol>\n<h4 id=\"需求分析-2\"><a class=\"anchor\" href=\"#需求分析-2\">#</a> 需求分析</h4>\n<ul>\n<li>设置营业状态</li>\n<li>管理端查询营业状态</li>\n<li>用户端查询营业状态</li>\n<li>营业状态数据存储方式：基于 <code>Redis</code>  的字符串来进行存储</li>\n</ul>\n<h3 id=\"微信登录\"><a class=\"anchor\" href=\"#微信登录\">#</a> 微信登录</h3>\n<p>添加小程序代码 (由他人开发，类似前端，由 js 文件组成)</p>\n<h4 id=\"具体实现-3\"><a class=\"anchor\" href=\"#具体实现-3\">#</a> 具体实现</h4>\n<ol>\n<li>​\t 小程序使用 <code>wx.login()</code>  获取 <code>code</code>  (授权码), 然后使用 <code>wx.request</code>  发送 code 到开发者服务器</li>\n<li>开发者服务器获得 <code>code</code>  后使用 <code>httpclient</code>  将 <code>appid</code> , <code>appsecret</code> , <code>code</code>  发送到微信接口</li>\n<li>微信接口返回 <code>session_key</code>  和 <code>openid</code>  (微信用户唯一标识，然后用其生成一个令牌给小程序</li>\n<li>最后小程序使用令牌来获取各种服务</li>\n</ol>\n<h3 id=\"商品与浏览功能\"><a class=\"anchor\" href=\"#商品与浏览功能\">#</a> 商品与浏览功能</h3>\n<h4 id=\"接口设计-5\"><a class=\"anchor\" href=\"#接口设计-5\">#</a> 接口设计</h4>\n<ul>\n<li>查询分类</li>\n<li>根据分类 <code>id</code>  查询菜品</li>\n<li>根据分类 <code>id</code>  查询套餐</li>\n<li>根据套餐 <code>id</code>  查询包含的菜品</li>\n</ul>\n<h3 id=\"缓存菜品\"><a class=\"anchor\" href=\"#缓存菜品\">#</a> 缓存菜品</h3>\n<h4 id=\"问题说明\"><a class=\"anchor\" href=\"#问题说明\">#</a> 问题说明</h4>\n<p>用户端小程序展示的菜品都是通过查询数据库获得，如果用户访问量比较大，数据库访问压力随之增大。</p>\n<h4 id=\"实现思路\"><a class=\"anchor\" href=\"#实现思路\">#</a> 实现思路</h4>\n<p>通过 <code>Redis</code>  来缓存菜品数据，减少数据库查询操作</p>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901111540778.png\" class=\"\" title=\"image-20240901111540778\"></p>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901111924695.png\" class=\"\" title=\"image-20240901111924695\"></p>\n<h3 id=\"缓存套餐\"><a class=\"anchor\" href=\"#缓存套餐\">#</a> 缓存套餐</h3>\n<h4 id=\"spring-cache\"><a class=\"anchor\" href=\"#spring-cache\">#</a> Spring Cache</h4>\n<p><code>Spring Cache</code>  是一个框架，实现了基于 <code>注解</code> 的缓存功能，只需简单地加一个注解，就能实现缓存功能</p>\n<p><code>Spring Cache</code>  提供了一层抽象，底层可以切换不同的缓存实现，例如:</p>\n<ul>\n<li><code>EHCache</code></li>\n<li><code>Caffeine</code></li>\n<li><code>Redis</code></li>\n</ul>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901112515899.png\" class=\"\" title=\"image-20240901112515899\"></p>\n<h3 id=\"添加购物车\"><a class=\"anchor\" href=\"#添加购物车\">#</a> 添加购物车</h3>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901115033152.png\" class=\"\" title=\"image-20240901115033152\"></p>\n<p>对购物车表添加冗余字段，这样就无须多表联合查询，增加速度</p>\n<h3 id=\"查看购物车\"><a class=\"anchor\" href=\"#查看购物车\">#</a> 查看购物车</h3>\n<h3 id=\"清空购物车\"><a class=\"anchor\" href=\"#清空购物车\">#</a> 清空购物车</h3>\n<h3 id=\"导入地址簿\"><a class=\"anchor\" href=\"#导入地址簿\">#</a> 导入地址簿</h3>\n<h4 id=\"业务功能\"><a class=\"anchor\" href=\"#业务功能\">#</a> 业务功能</h4>\n<ul>\n<li>查询地址列表</li>\n<li>新增地址</li>\n<li>修改地址</li>\n<li>删除地址</li>\n<li>设置默认地址</li>\n<li>查询默认地址</li>\n</ul>\n<h4 id=\"具体实现-4\"><a class=\"anchor\" href=\"#具体实现-4\">#</a> 具体实现</h4>\n<p>订单与订单明细表是一对多的关系</p>\n<ol>\n<li>处理各种业务异常 (地址簿为空 / 购物车为空)</li>\n<li>向订单表插入一条数据</li>\n<li>向订单表明细插入 n 条数据</li>\n<li>清空当前用户的购物车数据</li>\n<li>封装 VO 返回结果</li>\n</ol>\n<h3 id=\"微信支付\"><a class=\"anchor\" href=\"#微信支付\">#</a> 微信支付</h3>\n<ol>\n<li>首先用户向商户系统 (即本项目) 发出下单请求</li>\n<li>返回订单号</li>\n<li>在向商户系统申请微信支付</li>\n<li>商户系统调用微信下单接口，返回支付参数 (此时为预下单)</li>\n<li>最后用户用支付参数调起微信支付</li>\n<li>返回支付结果，同时商户系统获取支付结果并更新订单状态</li>\n</ol>\n<h3 id=\"订单状态定时处理\"><a class=\"anchor\" href=\"#订单状态定时处理\">#</a> 订单状态定时处理</h3>\n<h4 id=\"spring-task\"><a class=\"anchor\" href=\"#spring-task\">#</a> Spring Task</h4>\n<p><code>Spring Task</code>  是 <code>Spring</code>  框架提供的任务调度工具，可以按照\t约定的时间自动执行某个代码逻辑</p>\n<h4 id=\"cron表达式\"><a class=\"anchor\" href=\"#cron表达式\">#</a> cron 表达式</h4>\n<p><code>cron</code>  表达式其实就是一个字符串，通过 <code>cron</code>  表达式可以 <code>定义任务触发的时间</code></p>\n<p>构成规则：分为 <code>6</code>  或 <code>7</code>  个域，由空格分隔开，每个域代表一个含义 (秒 / 分钟 / 小时 / 日 / 月 / 周 / 年 (可选))</p>\n<p><img data-src=\"/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/image-20240901134936435.png\" class=\"\" title=\"image-20240901134936435\"></p>\n<p>在线生成 <code>cron</code>  表达式</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcm9uLnFxZTIuY29tLw==\">在线 Cron 表达式生成器 (qqe2.com)</span></p>\n<h4 id=\"需求分析-3\"><a class=\"anchor\" href=\"#需求分析-3\">#</a> 需求分析</h4>\n<p>问题:</p>\n<ul>\n<li>用户下单后未支付，订单一直处于 <code>&quot;待支付&quot;</code>  状态</li>\n<li>用户收货后管理端未点击完成按钮，订单一直处于 <code>&quot;派送中&quot;</code>  状态</li>\n</ul>\n<p>解决:</p>\n<ul>\n<li>通过定时任务 <code>每分钟检查一次</code> 是否存在超时订单 (下单后超过 15 分钟未支付), 如果则存在修改为 &quot;已取消&quot;</li>\n<li>通过定时任务 <code>每天凌晨检查一次</code> 是否存在 &quot;派送中&quot; 的订单，如果存在则修改为 &quot;已完成&quot;</li>\n</ul>\n<h3 id=\"来单提醒\"><a class=\"anchor\" href=\"#来单提醒\">#</a> 来单提醒</h3>\n<h4 id=\"websocket\"><a class=\"anchor\" href=\"#websocket\">#</a> WebSocket</h4>\n<p><code>WebSocket</code>  是基于 <code>TCP</code>  的一种新的网络协议。它实现了浏览器与服务器全双工通信 —— 浏览器和服务器只需要完成一次握手，两者之间就可以创建 <code>持久性</code> 的连接，并进行\t <code>双向</code> 数据传输。</p>\n<h4 id=\"需求分析-4\"><a class=\"anchor\" href=\"#需求分析-4\">#</a> 需求分析</h4>\n<p>用户下单并且支付成功后，需要第一时间通知外卖商家。通知形式有如下两种：</p>\n<ul>\n<li>语言播报</li>\n<li>弹出提示框</li>\n</ul>\n<p>设计：</p>\n<ul>\n<li>通过 <code>WebSocket</code>  实现管理端页面和服务端保持长连接状态</li>\n<li>当客户支付后，调用 <code>WebSocket</code>  的相关 <code>API</code>  实现服务端向客户端推送消息</li>\n<li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li>\n<li>约定服务端发送给客户端浏览器的数据格式为 <code>JSON</code> , 字段包括: <code>type</code> , <code>orderId</code> , <code>content</code>\n<ul>\n<li><code>type</code>  为消息类型， <code>1</code>  为来单提醒， <code>2</code>  为客户催单</li>\n<li><code>orderId</code>  为订单 <code>id</code></li>\n<li><code>content</code>  为消息内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"营业额统计\"><a class=\"anchor\" href=\"#营业额统计\">#</a> 营业额统计</h3>\n<h4 id=\"apache-echarts\"><a class=\"anchor\" href=\"#apache-echarts\">#</a> Apache ECharts</h4>\n<p>使用 <code>ECharts</code> , 重点在于研究当前图表所需的 <code>数据格式</code> 。通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。</p>\n<h3 id=\"用户统计\"><a class=\"anchor\" href=\"#用户统计\">#</a> 用户统计</h3>\n<p>统计用户数量</p>\n<h3 id=\"订单统计\"><a class=\"anchor\" href=\"#订单统计\">#</a> 订单统计</h3>\n<h3 id=\"销量排名统计\"><a class=\"anchor\" href=\"#销量排名统计\">#</a> 销量排名统计</h3>\n<h3 id=\"工作台\"><a class=\"anchor\" href=\"#工作台\">#</a> 工作台</h3>\n<p>工作台是系统运营的看板，并提供快捷操作入口，可以有效提高商家的工作效率</p>\n<p>工作台展示的数据</p>\n<ul>\n<li>今日数据</li>\n<li>订单管理</li>\n<li>菜品总览</li>\n<li>套餐总览</li>\n<li>订单信息</li>\n</ul>\n<p>每组数据对应一个接口，减少代码耦合性</p>\n<h3 id=\"导出运营数据excel报表\"><a class=\"anchor\" href=\"#导出运营数据excel报表\">#</a> 导出运营数据 Excel 报表</h3>\n<h4 id=\"apache-poi\"><a class=\"anchor\" href=\"#apache-poi\">#</a> Apache POI</h4>\n<p><code>Apache POI</code>  是一个处理 <code>Microsoft Office</code>  各种文件格式的开源项目。简单来说就是，我们可以使用 <code>POI</code>  在 <code>Java</code>  程序中对 <code>Microsoft Office</code>  各种文件进行读写操作。</p>\n<p>一般情况下， <code>POI</code>  都是用于操作 <code>Excel</code>  文件。</p>\n<p>应用场景：</p>\n<ul>\n<li>银行网银系统导出交易明细</li>\n<li>各种业务系统导出 <code>Excel</code>  报表</li>\n<li>批量导入业务数据</li>\n</ul>\n<h4 id=\"需求分析-5\"><a class=\"anchor\" href=\"#需求分析-5\">#</a> 需求分析</h4>\n<ul>\n<li>导出 <code>Excel</code>  形式的报表文件</li>\n<li>导出最近 30 天的运营数据</li>\n</ul>\n<p><code>当前接口没有返回数据,因为报表导出的本质是文件下载</code></p>\n<p>服务端会通过输出流将 <code>Excel</code>  文件下载到客户端浏览器</p>\n<h2 id=\"亮点难点\"><a class=\"anchor\" href=\"#亮点难点\">#</a> 亮点难点</h2>\n<h3 id=\"nginx反向代理和负载均衡\"><a class=\"anchor\" href=\"#nginx反向代理和负载均衡\">#</a> Nginx 反向代理和负载均衡</h3>\n<p><code>Nginx</code>  是一款轻量级的 <code>web</code>  服务器，反向代理服务器、电子邮件代理服务器，特点是占有内存少、并发能力强。Nginx 反向代理就是将前端发送的动态请求由 Nginx 转发到后端服务器，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p>\n<p>Nginx 反向代理的好处：</p>\n<ul>\n<li>提高访问速度：因为 nginx 本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx 就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</li>\n<li>进行负载均衡：所谓负载均衡，就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</li>\n<li>保证后端服务安全：因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把 nginx 作为请求访问的入口，请求到达 nginx 后转发到具体的服务中，从而保证后端服务的安全。</li>\n</ul>\n<details class=\"success\"><summary>负载均衡</summary><div>\n<p>负载均衡（Load Balancing）是一种技术，用于将网络流量或工作负载分配到多个服务器或计算资源上，以提高系统的性能、可靠性和可扩展性。它的主要目标是确保每个服务器的负载尽可能均衡，从而避免单个服务器过载，提升整体系统的响应速度和可用性。</p>\n<p>负载均衡的实现方式</p>\n<ol>\n<li>硬件负载均衡<br />\n硬件负载均衡器是专用设备，通常具有高性能和高可靠性。常见的硬件负载均衡器包括 F5 和 A10。</li>\n</ol>\n<p>优点：性能强大，支持复杂的负载均衡算法，安全性高。<br />\n缺点：成本高，扩展性差。</p>\n<ol start=\"2\">\n<li>软件负载均衡<br />\n软件负载均衡器运行在标准服务器上，常见的有 Nginx、HAProxy 和 LVS。</li>\n</ol>\n<p>优点：成本低，扩展性好，易于部署和维护。<br />\n缺点：性能相对硬件负载均衡器略低。<br />\n负载均衡的常见算法<br />\n轮询（Round Robin）：将请求依次分配给每个服务器，适用于负载均衡器和服务器性能相近的情况。<br />\n加权轮询（Weighted Round Robin）：根据服务器的性能分配权重，性能高的服务器分配更多请求。<br />\n最少连接（Least Connections）：将请求分配给当前连接数最少的服务器，适用于长连接的情况。<br />\n源地址哈希（Source IP Hash）：根据请求源 IP 地址的哈希值分配服务器，适用于需要会话保持的情况。<br />\n负载均衡的应用场景<br />\n Web 服务器集群：通过负载均衡分配 HTTP 请求，提高网站的并发处理能力。<br />\n数据库集群：分配数据库查询请求，提升数据库的读写性能。<br />\n微服务架构：在微服务架构中，负载均衡用于分配服务请求，确保各个服务实例的负载均衡。</p>\n</div></details>\n<h3 id=\"使用jwt\"><a class=\"anchor\" href=\"#使用jwt\">#</a> 使用 JWT</h3>\n<p>原本计划使用 Session 和验证码，考虑到如下因素最后选择了 <code>JWT</code></p>\n<p>使用 JWT（JSON Web Token）相比传统的 Session 和验证码有以下几个优点：</p>\n<ol>\n<li>\n<p>无状态性<br />\n优点：JWT 是无状态的，服务器不需要存储会话信息。每个请求都携带 JWT，服务器只需验证 JWT 的有效性即可。这使得 JWT 非常适合分布式系统和微服务架构。</p>\n</li>\n<li>\n<p>可扩展性<br />\n优点：由于 JWT 包含了用户信息和声明，可以在不同的服务器之间传递和验证。这解决了 Session 在跨服务器交换数据时的局限性。</p>\n</li>\n<li>\n<p>减少服务器负担<br />\n优点：JWT 存储在客户端（如 Local Storage 或 Cookie 中），每次请求都携带 JWT，减少了服务器的会话管理开销。这对于高并发应用尤其有利。</p>\n</li>\n<li>\n<p>跨语言支持<br />\n优点：JWT 采用 JSON 格式，易于读写，适用于多种编程语言。这使得 JWT 在不同技术栈之间的集成变得更加容易。</p>\n</li>\n<li>\n<p>安全性<br />\n优点：JWT 通过签名机制确保数据的完整性和真实性。虽然 JWT 的 Payload 部分没有加密，但签名可以防止数据被篡改。</p>\n</li>\n<li>\n<p>灵活性<br />\n优点：JWT 可以存储一些常用信息，用于交换信息。这可以减少服务器查询数据库的次数，提高性能。</p>\n</li>\n<li>\n<p>适用于移动端和单页应用<br />\n优点：JWT 特别适合移动端应用和单页应用（SPA），因为它们通常需要跨域请求和无状态认证。</p>\n</li>\n<li>\n<p>简化认证流程<br />\n优点：JWT 可以简化认证流程，用户登录后，服务器生成 JWT 并返回给客户端，客户端在后续请求中携带 JWT 即可。</p>\n</li>\n</ol>\n<p>当然，JWT 也有一些缺点，比如：</p>\n<ul>\n<li>安全性：由于 Payload 部分没有加密，不能存储敏感数据。</li>\n<li>性能：JWT 较长，每次请求都携带 JWT，可能增加网络传输开销。</li>\n</ul>\n<h3 id=\"高并发处理\"><a class=\"anchor\" href=\"#高并发处理\">#</a> 高并发处理</h3>\n<p>由于菜品表，套餐表都存储在硬盘上，故当多人请求时，难免会出现卡顿，影响用户体验，因此我使用 <code>Redis</code>  进行缓存。这样由于数据存储在内存中，数据获取效率大大提升.</p>\n<h2 id=\"细节补充\"><a class=\"anchor\" href=\"#细节补充\">#</a> 细节补充</h2>\n<h3 id=\"实现功能\"><a class=\"anchor\" href=\"#实现功能\">#</a> 实现功能</h3>\n<h4 id=\"管理端-2\"><a class=\"anchor\" href=\"#管理端-2\">#</a> 管理端</h4>\n<p>实现了员工，分类，菜品，套餐，订单管理</p>\n<p>工作台用于快速到达所需功能，来单提醒用于接单</p>\n<p>最后还有数据统计，包括可视化图表与 <code>excel</code>  导出</p>\n<h4 id=\"用户端-2\"><a class=\"anchor\" href=\"#用户端-2\">#</a> 用户端</h4>\n<p>用户端主要使用微信小程序进行下单</p>\n<p>包括常见的微信登录，支付，商品浏览下单，购物车</p>\n<p>历史订单，地址管理，用户催单功能</p>\n<h3 id=\"细节问题\"><a class=\"anchor\" href=\"#细节问题\">#</a> 细节问题</h3>\n<details class=\"success\"><summary>该项目有哪些模块，作用分别是什么</summary><div>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>模块</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>sky-take-out</td>\n<td>maven 父工程，统一管理依赖版本，聚合其他子模块</td>\n</tr>\n<tr>\n<td>2</td>\n<td>sky-common</td>\n<td>子模块，存放公共类，例如：工具类、常量类、异常类等</td>\n</tr>\n<tr>\n<td>3</td>\n<td>sky-pojo</td>\n<td>子模块，存放实体类、VO、DTO 等</td>\n</tr>\n<tr>\n<td>4</td>\n<td>sky-server</td>\n<td>子模块，后端服务，存放配置文件、Controller、Service、Mapper 等</td>\n</tr>\n</tbody>\n</table>\n</div></details>\n<details class=\"success\"><summary>概述登录流程怎么实现的，为什么要加拦截器</summary><div>\n<h3 id=\"登录流程\"><a class=\"anchor\" href=\"#登录流程\">#</a> 登录流程</h3>\n<ol>\n<li><strong>用户提交登录请求</strong>：用户在前端输入用户名和密码，提交登录请求。</li>\n<li><strong>服务器验证用户信息</strong>：服务器接收到请求后，验证用户名和密码是否正确。</li>\n<li><strong>生成 JWT 令牌</strong>：如果验证通过，服务器生成一个 JWT（JSON Web Token）令牌，并将其返回给前端。</li>\n<li><strong>前端存储令牌</strong>：前端接收到 JWT 令牌后，将其存储在本地（如 LocalStorage 或 SessionStorage）。</li>\n<li><strong>携带令牌访问受保护资源</strong>：在后续的请求中，前端会在请求头中携带 JWT 令牌，以访问受保护的资源。</li>\n</ol>\n<h3 id=\"为什么要加拦截器\"><a class=\"anchor\" href=\"#为什么要加拦截器\">#</a> 为什么要加拦截器</h3>\n<p>拦截器在登录流程中起到了关键作用，主要有以下几个原因：</p>\n<ol>\n<li><strong>验证请求合法性</strong>：拦截器可以在每次请求到达服务器之前，检查请求头中是否包含有效的 JWT 令牌。如果没有令牌或令牌无效，拦截器可以直接拒绝请求，确保只有合法用户才能访问受保护的资源。</li>\n<li><strong>简化代码</strong>：通过拦截器，可以将令牌验证的逻辑集中处理，避免在每个受保护的接口中重复编写验证代码，提高代码的可维护性。</li>\n<li><strong>增强安全性</strong>：拦截器可以防止未授权的访问，保护敏感数据和功能不被非法用户获取。</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>ThreadLocal作用是什么，怎么使用的</summary><div>\n<p>是线程的局部变量，在登录过程中，作为媒介，将用户 <code>id</code>  传给 save 方法保存信息</p>\n</div></details>\n<details class=\"success\"><summary>为什么做全局异常处理，怎么实现的</summary><div>\n<p>原因：抛出的自定义异常不会提示给用户，真正出异常又会给客户端一堆看不懂的提示，因此需要全局异常处理</p>\n<p>实现：server 模块下，exception 文件夹下</p>\n</div></details>\n<details class=\"success\"><summary>分类删除注意什么问题？怎么实现的</summary><div>\n<h3 id=\"注意事项\"><a class=\"anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ol>\n<li><strong>检查关联数据</strong>：\n<ul>\n<li><strong>菜品</strong>：确保该分类下没有关联的菜品。如果有，需要先处理这些菜品（如重新分类或删除）。</li>\n<li><strong>套餐</strong>：确保该分类下没有关联的套餐。</li>\n</ul>\n</li>\n<li><strong>数据完整性</strong>：\n<ul>\n<li><strong>事务管理</strong>：使用事务管理，确保删除操作的原子性，避免部分删除导致数据不一致。</li>\n<li><strong>级联删除</strong>：如果有级联关系（如分类删除后需要删除关联的菜品），需要确保级联删除的正确性。</li>\n</ul>\n</li>\n<li><strong>业务规则</strong>：\n<ul>\n<li><strong>状态检查</strong>：通常不允许删除正在使用中的分类（如有菜品正在销售）。</li>\n<li><strong>权限控制</strong>：确保只有有权限的用户才能执行删除操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实现步骤\"><a class=\"anchor\" href=\"#实现步骤\">#</a> 实现步骤</h3>\n<ol>\n<li><strong>检查关联数据</strong>：\n<ul>\n<li>在删除分类前，查询该分类下是否有菜品或套餐。</li>\n</ul>\n</li>\n<li><strong>删除分类</strong>：\n<ul>\n<li>如果没有关联数据，可以安全删除分类。</li>\n</ul>\n</li>\n<li><strong>事务管理</strong>：\n<ul>\n<li>使用  <code>@Transactional</code>  注解确保操作的原子性。</li>\n</ul>\n</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>AOP字段填充怎么实现的</summary><div>\n<ol>\n<li>\n<p>自定义注解</p>\n<p>用于标识需要自动填充字段的方法</p>\n</li>\n<li>\n<p>定义切面类</p>\n<p>创建一个切面类，拦截带有 <code>@AutoFill</code>  注解的方法，并通过反射为实体对象的公共字段赋值</p>\n</li>\n<li>\n<p>在 <code>Mapper</code>  方法上使用注解</p>\n<p>在需要自动填充字段的方法上添加 <code>@AutoFill</code>  注解</p>\n</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>文件上传有哪些方式，项目中怎么实现的</summary><div>\n<ul>\n<li>\n<p><strong>本地存储</strong>：</p>\n<ul>\n<li><strong>优点</strong>：开发简单，成本低。</li>\n<li><strong>缺点</strong>：扩展性差，服务器存储空间有限。</li>\n<li>实现步骤：\n<ol>\n<li>前端通过表单上传文件，使用  <code>multipart/form-data</code>  编码类型。</li>\n<li>后端接收文件并保存到服务器指定目录。</li>\n<li>返回文件的访问路径给前端。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>云存储（如阿里云 OSS）</strong>：</p>\n<ul>\n<li><strong>优点</strong>：扩展性好，支持大规模存储，免维护。</li>\n<li><strong>缺点</strong>：需要付费。</li>\n<li>实现步骤：\n<ol>\n<li>配置阿里云 OSS 相关信息（如 endpoint、accessKeyId、accessKeySecret、bucketName）。</li>\n<li>使用阿里云 OSS SDK 上传文件到云存储。</li>\n<li>返回文件的访问路径给前端。</li>\n</ol>\n</li>\n</ul>\n<p>之前学习的项目都是本地存储，本着尝试的目的，并且作为学生可以试用阿里云 oss, 故使用阿里云 oss, 采用云存储的方式上传图片</p>\n</li>\n</ul>\n</div></details>\n<details class=\"success\"><summary>菜品分页需要关联展示分类名称，怎么实现的</summary><div>\n<p>前端提交的数据与实体类差距较大，例如状态，时间等是实体类没有的，故使用 DTO 类封装数据，然后就是惯例的 <code>Mapper</code> , <code>Controller</code> , <code>Service</code> .</p>\n</div></details>\n<details class=\"success\"><summary>菜品修改时，关联的菜品口味如何修改的</summary><div>\n<ol>\n<li><strong>获取菜品信息</strong>：\n<ul>\n<li>首先，从数据库中获取需要修改的菜品信息，包括其关联的口味信息。</li>\n</ul>\n</li>\n<li><strong>修改菜品信息</strong>：\n<ul>\n<li>更新菜品的基本信息，如名称、价格、描述等。</li>\n</ul>\n</li>\n<li><strong>更新关联的口味信息</strong>：\n<ul>\n<li>根据菜品的 ID，查询并更新其关联的口味信息。可以使用 MyBatis 的关联查询功能来实现这一点。</li>\n</ul>\n</li>\n<li><strong>保存修改</strong>：\n<ul>\n<li>将修改后的菜品信息和口味信息保存到数据库中。</li>\n</ul>\n</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>菜品起售停售注意事项，如何实现</summary><div>\n<p>这里要考虑的是数据一致性，确保菜品状态的修改不会影响其他关联数据的完整性。</p>\n<p>例如，停售菜品要检查是否有未完成的订单。</p>\n<p>由于涉及多表操作，建议使用事务管理来确保数据的一致性和操作的原子性</p>\n</div></details>\n<details class=\"success\"><summary>概述HttpClient的作用</summary><div>\n<p><code>HttpClient</code>  的主要作用是<strong>发送 HTTP 请求和接收响应数据</strong></p>\n<p>在本项目中， <code>HttpClient</code>  是将授权码 <code>code</code>  及 <code>appId</code>  和 <code>appsecret</code>  发送到微信接口</p>\n</div></details>\n<details class=\"success\"><summary>概述微信登录实现流程</summary><div>\n<ol>\n<li>​\t 小程序使用 <code>wx.login()</code>  获取 <code>code</code>  (授权码), 然后使用 <code>wx.request</code>  发送 code 到开发者服务器</li>\n<li>开发者服务器获得 <code>code</code>  后使用 <code>httpclient</code>  将 <code>appid</code> , <code>appsecret</code> , <code>code</code>  发送到微信接口</li>\n<li>微信接口返回 <code>session_key</code>  和 <code>openid</code>  (微信用户唯一标识，然后用其生成一个令牌给小程序</li>\n<li>最后小程序使用令牌来获取各种服务</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>小程序首页菜品数据怎么查询的</summary><div>\n<p>这部分是由他人负责的，但根据我的了解，主要还是后端编写查询接口，前端通过 <code>wx.request</code>  方法发送 <code>HTTP</code>  请求获取数据的</p>\n</div></details>\n<details class=\"success\"><summary>小程序首页套餐数据怎么查询的</summary><div>\n<p>同上</p>\n</div></details>\n<details class=\"success\"><summary>redis中有哪些数据类型</summary><div>\n<p>常见的有 <code>String</code> , <code>Hash</code> , <code>List</code> , <code>Set</code> , <code>ZSet</code>  等</p>\n</div></details>\n<details class=\"warning\"><summary>概述菜品缓存流程</summary><div>\n</div></details>\n<details class=\"warning\"><summary>数据库与redis如何实现的数据同步</summary><div>\n</div></details>\n<details class=\"warning\"><summary>为什么用了redis还用SpringCache</summary><div>\n</div></details>\n<details class=\"warning\"><summary>SpringCache有哪些注解</summary><div>\n</div></details>\n<details class=\"warning\"><summary>SpringCache在项目中如何使用的</summary><div>\n</div></details>\n<details class=\"warning\"><summary>概述添加购物车流程</summary><div>\n</div></details>\n<details class=\"warning\"><summary>概述订单提交实现流程</summary><div>\n</div></details>\n<details class=\"warning\"><summary>概述历史订单实现流程</summary><div>\n</div></details>\n<details class=\"warning\"><summary>概述再来一单实现流程</summary><div>\n</div></details>\n<details class=\"warning\"><summary>定时任务如何实现的</summary><div>\n</div></details>\n<details class=\"warning\"><summary>cron表达式有哪些特殊符号，分别表示什么意思</summary><div>\n</div></details>\n<details class=\"warning\"><summary>项目中定时任务如何使用的</summary><div>\n<p>使用 <code>cron</code>  表达式</p>\n</div></details>\n<details class=\"warning\"><summary>说说WebSocket和HTTP协议的区别</summary><div>\n</div></details>\n<details class=\"warning\"><summary>项目中用WebSocket实现了哪些功能，怎么实现的</summary><div>\n</div></details>\n<details class=\"warning\"><summary>营业额统计数据如何设计VO对象封装的</summary><div>\n</div></details>\n<details class=\"success\"><summary>Excel导入导出有哪些技术方案？</summary><div>\n<p>有很多，我最终使用的是 <code>Apache POI</code> , 针对 <code>Microsoft Office</code>  的开源项目</p>\n</div></details>\n<details class=\"success\"><summary>JWT储存在前端的哪个地方</summary><div>\n<p>在前端存储 JWT（JSON Web Token）时，有几种常见的方法，每种方法都有其优缺点：</p>\n<p>Local Storage：<br />\n优点：易于实现，持久化存储，即使刷新页面也不会丢失。<br />\n缺点：容易受到 XSS（跨站脚本）攻击，因为任何运行在同一域上的 JavaScript 代码都可以访问 Local Storage。<br />\nSession Storage：<br />\n优点：与 Local Storage 类似，但数据仅在会话期间有效，浏览器关闭后数据会被清除。<br />\n缺点：同样容易受到 XSS 攻击。<br />\nCookies：<br />\n优点：可以设置 HttpOnly 和 Secure 标志，增加安全性。HttpOnly 标志可以防止 JavaScript 访问 Cookie，从而减少 XSS 攻击的风险。Secure 标志确保 Cookie 只能通过 HTTPS 传输。<br />\n缺点：需要处理 CSRF（跨站请求伪造）攻击，可以通过使用 SameSite 属性来缓解。<br />\n内存中：<br />\n优点：最安全，因为数据仅在内存中存储，页面刷新或关闭浏览器后数据会丢失。<br />\n缺点：用户每次刷新页面或关闭浏览器后需要重新登录。<br />\n综合考虑安全性和易用性，使用 HttpOnly 和 Secure 标志的 Cookie 是推荐的存储方式。这种方法可以有效防止 XSS 攻击，同时通过适当的配置减少 CSRF 攻击的风险。</p>\n</div></details>\n<details class=\"success\"><summary>项目涉及https传输，说说其原理</summary><div>\n<p>HTTPS（HyperText Transfer Protocol Secure）是 HTTP 的安全版本，用于在客户端（如浏览器）和服务器之间安全地传输数据。它通过加密通信来保护数据的机密性和完整性。以下是 HTTPS 的工作原理：</p>\n<p>SSL/TLS 协议：<br />\nHTTPS 使用 SSL（Secure Sockets Layer）或其后继者 TLS（Transport Layer Security）协议来加密数据传输。TLS 是目前更常用的协议。<br />\n这些协议通过加密数据来防止数据在传输过程中被窃取或篡改。<br />\n公钥和私钥：<br />\nHTTPS 使用一种称为非对称加密的技术，这种技术使用一对密钥：公钥和私钥。<br />\n公钥用于加密数据，任何人都可以获取公钥并使用它来加密数据。<br />\n私钥用于解密数据，只有服务器拥有私钥。<br />\nSSL/TLS 证书：<br />\n服务器需要一个 SSL/TLS 证书来启用 HTTPS。证书由受信任的证书颁发机构（CA）签发，包含公钥和服务器的身份信息。<br />\n当客户端连接到服务器时，服务器会发送其 SSL/TLS 证书给客户端。<br />\n握手过程：<br />\n客户端和服务器通过一个称为握手的过程来建立安全连接。<br />\n在握手过程中，客户端验证服务器的证书，确保其真实性。<br />\n一旦验证通过，客户端和服务器将生成一个对称密钥，用于加密后续的通信。对称加密比非对称加密更快，因此用于实际的数据传输。<br />\n数据加密：<br />\n一旦握手完成，客户端和服务器之间的所有数据传输都将使用对称密钥进行加密。<br />\n这确保了即使数据在传输过程中被截获，攻击者也无法解密和读取数据。<br />\n通过这些步骤，HTTPS 提供了一个安全的通信渠道，保护敏感信息（如密码、信用卡信息等）在传输过程中的安全。</p>\n</div></details>\n<details class=\"success\"><summary>如何设计一个短信验证码登录</summary><div>\n<ol>\n<li><strong>前端请求验证码</strong>：\n<ul>\n<li>用户在登录页面输入手机号码并点击获取验证码按钮。</li>\n<li>前端发送请求到后端，要求发送短信验证码。</li>\n</ul>\n</li>\n<li><strong>后端生成验证码</strong>：\n<ul>\n<li>后端生成一个随机的验证码（通常是 6 位数字）。</li>\n<li>将验证码和手机号码关联，并存储在缓存中（如 Redis），设置一个有效期（如 5 分钟）。</li>\n</ul>\n</li>\n<li><strong>发送短信验证码</strong>：\n<ul>\n<li>使用第三方短信服务（如阿里云短信服务、腾讯云短信服务等）将验证码发送到用户的手机号码。</li>\n<li>确保短信内容简洁明了，包含验证码和有效期提示。</li>\n</ul>\n</li>\n<li><strong>用户输入验证码登录</strong>：\n<ul>\n<li>用户在登录页面输入收到的验证码和手机号码，并提交登录请求。</li>\n<li>前端将手机号码和验证码发送到后端进行验证。</li>\n</ul>\n</li>\n<li><strong>后端验证验证码</strong>：\n<ul>\n<li>后端接收到登录请求后，从缓存中获取存储的验证码。</li>\n<li>验证用户输入的验证码是否正确且在有效期内。</li>\n<li>如果验证通过，生成 JWT（JSON Web Token）或其他类型的令牌，并返回给前端。</li>\n</ul>\n</li>\n<li><strong>前端存储令牌</strong>：\n<ul>\n<li>前端接收到令牌后，将其存储在合适的位置（如 Local Storage、Session Storage 或 Cookie）。</li>\n<li>在后续的请求中，前端将令牌包含在请求头中，以便后端进行身份验证。</li>\n</ul>\n</li>\n</ol>\n</div></details>\n<details class=\"success\"><summary>怎么拦截获取验证码的重复请求</summary><div>\n<p>为了防止用户重复请求验证码，可以采取以下几种方法：</p>\n<p>前端按钮禁用：<br />\n在用户点击获取验证码按钮后，将按钮禁用一段时间（例如 60 秒），防止用户在短时间内多次点击。<br />\n可以使用 JavaScript 设置一个倒计时，倒计时结束后重新启用按钮。</p>\n<p>后端请求频率限制：<br />\n在后端设置一个请求频率限制，例如每个手机号码每分钟只能请求一次验证码。<br />\n可以使用 Redis 等缓存工具来存储请求时间，并在每次请求时检查是否超过了限制。</p>\n<p>唯一请求标识：<br />\n使用唯一请求标识（如 UUID）来标识每个请求，并在后端记录这些标识。<br />\n如果检测到重复的请求标识，则拒绝处理该请求。</p>\n<p>通过这些方法，可以有效地防止用户重复请求验证码，提升系统的安全性和用户体验。</p>\n</div></details>\n<details class=\"success\"><summary>get与post的区别</summary><div>\n<p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在使用场景和特性上有一些重要的区别：</p>\n<p>用途：<br />\nGET：主要用于从服务器获取数据。请求参数会附加在 URL 后面。<br />\nPOST：主要用于向服务器提交数据。请求参数包含在请求体中。<br />\n安全性：<br />\nGET：参数暴露在 URL 中，容易被截获，不适合传输敏感信息。<br />\nPOST：参数在请求体中，相对更安全，但仍需使用 HTTPS 保护数据传输。<br />\n数据长度限制：<br />\nGET：由于 URL 长度限制，传输的数据量有限（通常不超过 2048 个字符）。<br />\nPOST：没有数据长度限制，可以传输大量数据。<br />\n幂等性：<br />\nGET：是幂等的，多次请求同一资源不会改变服务器状态。<br />\nPOST：不是幂等的，多次请求可能会导致不同的结果（如多次提交表单）。<br />\n缓存：<br />\nGET：请求可以被缓存，适合获取静态资源。<br />\nPOST：请求不会被缓存，适合提交动态数据。<br />\n浏览器行为：<br />\nGET：请求参数会保留在浏览器历史记录中，可以被书签保存。<br />\nPOST：请求参数不会保留在浏览器历史记录中，不能被书签保存。<br />\n这些区别决定了 GET 和 POST 在不同场景下的适用性。例如，GET 适用于获取数据而不改变服务器状态的操作，而 POST 适用于提交数据或改变服务器状态的操作。</p>\n</div></details>\n<details class=\"success\"><summary>简述一个HTTP请求结构</summary><div>\n<p>一个 HTTP 请求由以下几个部分组成：</p>\n<ol>\n<li>\n<p><strong>请求行（Request Line）</strong>：</p>\n<ul>\n<li><strong>方法（Method）</strong>：指定要执行的操作，如 GET、POST、PUT、DELETE 等。</li>\n<li><strong>请求 URI（Request URI）</strong>：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li>\n<li><strong>HTTP 版本（HTTP Version）</strong>：如 HTTP/1.1 或 HTTP/2。</li>\n</ul>\n<p>示例：</p>\n<pre><code>GET /index.html HTTP/1.1\n</code></pre>\n</li>\n<li>\n<p><strong>请求头部（Request Headers）</strong>：</p>\n<ul>\n<li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li>\n<li>常见的请求头包括 Host、User-Agent、Accept、Accept-Encoding、Content-Length 等。</li>\n</ul>\n<p>示例：</p>\n<pre><code>Host: www.example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n</code></pre>\n</li>\n<li>\n<p><strong>空行（Blank Line）</strong>：</p>\n<ul>\n<li>请求头和请求体之间的分隔符，表示请求头的结束。</li>\n</ul>\n</li>\n<li>\n<p><strong>请求体（Request Body）</strong>（可选）：</p>\n<ul>\n<li>在某些类型的 HTTP 请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li>\n</ul>\n<p>示例：</p>\n<pre><code>param1=value1&amp;param2=value2\n</code></pre>\n</li>\n</ol>\n<p>一个完整的 HTTP 请求示例如下：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\n</code></pre>\n<p>在这个示例中，请求行指定了使用 GET 方法请求  <code>/index.html</code>  资源，使用 HTTP/1.1 协议。请求头部包含了主机名、用户代理、接受的内容类型和编码方式等信息。由于这是一个 GET 请求，没有请求体。</p>\n</div></details>\n<details class=\"success\"><summary>GET可以传输数据吗</summary><div>\n<p>GET 请求可以传输数据，但数据是通过 URL 参数传递的，而不是在请求体中。具体来说，GET 请求会将数据附加在 URL 的查询字符串中。例如：</p>\n<p>GET /search?q=example HTTP/1.1<br />\nHost: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==\">www.example.com</span></p>\n<p>在这个例子中，q=example 是通过 URL 参数传递的数据。</p>\n<p>需要注意的是，GET 请求有一些限制和特点：</p>\n<p>数据长度限制：由于 URL 长度有限（通常不超过 2048 个字符），GET 请求传输的数据量有限。<br />\n安全性：因为数据暴露在 URL 中，GET 请求不适合传输敏感信息，如密码或个人数据。<br />\n缓存：GET 请求可以被缓存，这对于获取静态资源非常有用。<br />\n幂等性：GET 请求是幂等的，多次请求同一资源不会改变服务器状态。<br />\n如果需要传输大量数据或敏感信息，建议使用 POST 请求，因为 POST 请求的数据包含在请求体中，不会暴露在 URL 中。</p>\n</div></details>\n<details class=\"success\"><summary>进程与线程</summary><div>\n<p>进程和线程是操作系统中的两个重要概念，它们在计算机系统中扮演着不同的角色。</p>\n<h3 id=\"进程\"><a class=\"anchor\" href=\"#进程\">#</a> 进程</h3>\n<ul>\n<li><strong>定义</strong>：进程是一个正在运行的程序实例，是操作系统进行资源分配和调度的基本单位。</li>\n<li>特点：\n<ul>\n<li>每个进程都有独立的内存空间，包括代码段、数据段、堆和栈。</li>\n<li>进程之间相互独立，一个进程的崩溃不会影响其他进程。</li>\n<li>进程切换开销较大，因为需要保存和恢复大量的上下文信息。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h3>\n<ul>\n<li><strong>定义</strong>：线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。</li>\n<li>特点：\n<ul>\n<li>线程共享进程的内存空间（代码段、数据段、堆），但每个线程有自己的栈和寄存器。</li>\n<li>线程之间的切换开销较小，因为共享了进程的大部分资源。</li>\n<li>一个进程可以包含多个线程，这些线程可以并发执行，提高程序的执行效率。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程与线程的区别\"><a class=\"anchor\" href=\"#进程与线程的区别\">#</a> 进程与线程的区别</h3>\n<ol>\n<li><strong>资源分配</strong>：进程是资源分配的基本单位，而线程是 CPU 调度的基本单位。</li>\n<li><strong>内存空间</strong>：进程有独立的内存空间，线程共享进程的内存空间。</li>\n<li><strong>开销</strong>：进程切换开销大，线程切换开销小。</li>\n<li><strong>独立性</strong>：进程之间相互独立，一个进程的崩溃不会影响其他进程；而线程之间相互依赖，一个线程的崩溃可能导致整个进程崩溃。</li>\n</ol>\n<h3 id=\"实际应用\"><a class=\"anchor\" href=\"#实际应用\">#</a> 实际应用</h3>\n<p>在实际开发中，使用多线程可以提高程序的并发性和响应速度。例如，在一个 Web 服务器中，可以为每个请求创建一个线程来处理，从而提高服务器的吞吐量和响应速度。</p>\n</div></details>\n<details class=\"success\"><summary>TCP，UDP以及IP相关知识</summary><div>\n<ol>\n<li>TCP 和 UDP 的区别<br />\n考察点：</li>\n</ol>\n<p>是否了解 TCP 和 UDP 的基本特性和应用场景。<br />\n回答思路：</p>\n<p>连接性：TCP 是面向连接的协议，需要建立连接（通过三次握手）后才能传输数据；UDP 是无连接的协议，不需要建立连接。<br />\n可靠性：TCP 提供可靠的数据传输，具有确认应答、重传机制和流量控制；UDP 不保证数据的可靠性，适用于实时应用。<br />\n传输方式：TCP 是面向字节流的，数据按顺序传输；UDP 是面向报文的，每个报文独立传输。<br />\n开销：TCP 的首部较大（20 字节），UDP 的首部较小（8 字节）。<br />\n应用场景：TCP 适用于需要可靠传输的场景，如文件传输、邮件；UDP 适用于对速度要求高但对可靠性要求低的场景，如视频直播、在线游戏。<br />\n2. TCP 的可靠性机制<br />\n考察点：</p>\n<p>是否了解 TCP 如何保证数据传输的可靠性。<br />\n回答思路：</p>\n<p>校验和：用于检测数据在传输过程中是否被篡改。<br />\n确认应答和序列号：每个数据包都有序列号，接收方收到数据后会发送确认应答（ACK），发送方只有收到 ACK 后才会发送下一个数据包。<br />\n超时重传：如果发送方在一定时间内没有收到 ACK，会重传数据包。<br />\n流量控制：通过滑动窗口机制，控制发送方的发送速度，以适应接收方的处理能力。<br />\n拥塞控制：通过慢启动、拥塞避免、快速重传和快速恢复等算法，防止网络拥塞。<br />\n3. TCP 的三次握手和四次挥手<br />\n考察点：</p>\n<p>是否了解 TCP 连接的建立和关闭过程。<br />\n回答思路：</p>\n<p>三次握手：<br />\n客户端发送 SYN 报文，表示请求建立连接。<br />\n服务器收到 SYN 后，发送 SYN-ACK 报文，表示同意建立连接。<br />\n客户端收到 SYN-ACK 后，发送 ACK 报文，连接建立完成。<br />\n四次挥手：<br />\n客户端发送 FIN 报文，表示请求关闭连接。<br />\n服务器收到 FIN 后，发送 ACK 报文，表示同意关闭连接。<br />\n服务器发送 FIN 报文，表示准备关闭连接。<br />\n客户端收到 FIN 后，发送 ACK 报文，连接关闭完成。<br />\n4. IP 协议<br />\n考察点：</p>\n<p>是否了解 IP 协议的基本概念和功能。<br />\n回答思路：</p>\n<p>IP 地址：用于标识网络中的设备，每个设备都有一个唯一的 IP 地址。<br />\n路由：IP 协议负责将数据包从源地址传输到目标地址，通过路由器进行转发。<br />\n分片和重组：如果数据包超过网络的最大传输单元（MTU），IP 协议会将其分片传输，并在目标地址进行重组。<br />\n版本：IPv4 和 IPv6 是两种主要的 IP 协议版本，IPv6 提供了更大的地址空间和更好的安全性。</p>\n</div></details>\n<details class=\"success\"><summary>DNS相关知识</summary><div>\n<p>DNS（Domain Name System）服务器是互联网的一项基础服务，用于将域名转换为对应的 IP 地址，使用户能够通过易记的域名访问网站，而不是复杂的数字 IP 地址。以下是 DNS 服务器的相关知识：</p>\n<h3 id=\"dns-服务器的工作原理\"><a class=\"anchor\" href=\"#dns-服务器的工作原理\">#</a> DNS 服务器的工作原理</h3>\n<ol>\n<li><strong>域名解析</strong>：\n<ul>\n<li>当用户在浏览器中输入一个域名（如 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==\">www.example.com</span>）时，浏览器会向 DNS 服务器发送查询请求，询问该域名对应的 IP 地址。</li>\n<li>DNS 服务器会查找其数据库，如果找到匹配的记录，就返回对应的 IP 地址。</li>\n</ul>\n</li>\n<li><strong>分层结构</strong>：\n<ul>\n<li>DNS 采用分层结构，包括根域名服务器、顶级域名服务器（如 .com、.org）、权威域名服务器和本地域名服务器。</li>\n<li>查询请求会从本地域名服务器开始，如果本地没有缓存记录，则逐级向上查询，直到根域名服务器。</li>\n</ul>\n</li>\n<li><strong>缓存机制</strong>：\n<ul>\n<li>为了提高查询效率，DNS 服务器会缓存查询结果。下次查询相同域名时，可以直接从缓存中获取结果，而不需要再次查询上级服务器。</li>\n</ul>\n</li>\n<li><strong>递归查询和迭代查询</strong>：\n<ul>\n<li><strong>递归查询</strong>：本地域名服务器代表用户向上级服务器查询，直到找到结果。</li>\n<li><strong>迭代查询</strong>：本地域名服务器向上级服务器查询时，上级服务器只返回下一步查询的地址，由本地服务器继续查询。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"常见的-dns-服务器\"><a class=\"anchor\" href=\"#常见的-dns-服务器\">#</a> 常见的 DNS 服务器</h3>\n<ul>\n<li><strong>公共 DNS 服务器</strong>：如 Google Public DNS（8.8.8.8）、Cloudflare DNS（1.1.1.1）、阿里云 DNS（223.5.5.5）等，提供快速、稳定的域名解析服务。</li>\n<li><strong>本地 DNS 服务器</strong>：由 ISP（互联网服务提供商）或企业内部部署，用于处理本地网络的域名解析请求。</li>\n</ul>\n<h3 id=\"dns-安全\"><a class=\"anchor\" href=\"#dns-安全\">#</a> DNS 安全</h3>\n<ul>\n<li><strong>DNS 劫持</strong>：攻击者通过篡改 DNS 记录，将用户引导到恶意网站。可以通过使用 DNSSEC（DNS Security Extensions）来防止。</li>\n<li><strong>DNS 缓存中毒</strong>：攻击者向 DNS 服务器注入虚假记录，导致用户访问错误的 IP 地址。使用安全的 DNS 服务器和定期清理缓存可以减少风险。</li>\n</ul>\n<h3 id=\"dns-在面试中的考察\"><a class=\"anchor\" href=\"#dns-在面试中的考察\">#</a> DNS 在面试中的考察</h3>\n<p><strong>考察点</strong>：</p>\n<ul>\n<li>是否了解 DNS 的基本概念和工作原理。</li>\n<li>是否了解 DNS 的分层结构和查询过程。</li>\n<li>是否了解常见的 DNS 安全问题及其防护措施。</li>\n</ul>\n<p><strong>回答思路</strong>：</p>\n<ul>\n<li>简要介绍 DNS 的作用和工作原理。</li>\n<li>说明 DNS 的分层结构和查询过程。</li>\n<li>提及常见的 DNS 服务器和其用途。</li>\n<li>讨论 DNS 安全问题及其防护措施。</li>\n</ul>\n</div></details>\n<details class=\"success\"><summary>mysql基本查询方法</summary><div>\n<p><code>SELECT</code>  语句<br />\n用于从数据库中检索数据。<br />\n-- 从表中选择所有列<br />\n <code>SELECT * FROM table_name;</code></p>\n<p>-- 从表中选择特定列<br />\n <code>SELECT column1, column2 FROM table_name;</code></p>\n<p><code>WHERE</code>  子句<br />\n用于根据指定条件过滤数据。<br />\n-- 选择满足条件的行<br />\n <code>SELECT * FROM table_name WHERE condition;</code></p>\n<p>-- 示例：选择年龄大于 30 的用户<br />\n <code>SELECT * FROM users WHERE age &gt; 30;</code></p>\n<p><code>ORDER BY</code>  子句<br />\n用于对结果集进行排序。<br />\n-- 按照指定列升序排序<br />\n <code>SELECT * FROM table_name ORDER BY column1 ASC;</code></p>\n<p>-- 按照指定列降序排序<br />\n <code>SELECT * FROM table_name ORDER BY column1 DESC;</code></p>\n<p><code>LIMIT </code> 子句<br />\n用于限制返回的行数。<br />\n-- 选择前 10 行<br />\n <code>SELECT * FROM table_name LIMIT 10;</code></p>\n<p><code>INSERT INTO </code> 语句<br />\n用于向表中插入新数据。<br />\n-- 插入一行数据<br />\n <code>INSERT INTO table_name (column1, column2) VALUES (value1, value2);</code></p>\n<p><code>UPDATE </code> 语句<br />\n用于修改表中的现有数据。<br />\n-- 更新满足条件的行<br />\n <code>UPDATE table_name SET column1 = value1 WHERE condition;</code></p>\n<p>-- 示例：将所有用户的年龄增加 1<br />\n <code>UPDATE users SET age = age + 1;</code></p>\n<p><code>DELETE </code> 语句<br />\n用于删除表中的数据。<br />\n-- 删除满足条件的行<br />\n <code>DELETE FROM table_name WHERE condition;</code></p>\n<p>-- 示例：删除年龄小于 18 的用户<br />\n <code>DELETE FROM users WHERE age &lt; 18;</code></p>\n<p><code>GROUP BY </code> 子句<br />\n用于将结果集中的行分组，并对每个组进行聚合操作。<br />\n-- 按照指定列分组<br />\n <code>SELECT column1, COUNT(*) FROM table_name GROUP BY column1;</code></p>\n<p>-- 示例：按年龄分组并统计每个年龄段的用户数量<br />\n <code>SELECT age, COUNT(*) FROM users GROUP BY age;</code></p>\n<p><code>JOIN</code>  操作<br />\n用于从多个表中检索数据。<br />\n-- 内连接<br />\n <code>SELECT * FROM table1 INNER JOIN table2 ON table1.column = table2.column;</code></p>\n<p>-- 左连接<br />\n <code>SELECT * FROM table1 LEFT JOIN table2 ON table1.column = table2.column;</code></p>\n<p>-- 右连接<br />\n <code>SELECT * FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;</code></p>\n<p><code>WHERE</code>  与 <code> HAVING</code>  的区别<br />\n <code>WHERE </code> 子句：在分组和聚合之前筛选记录，不能包含聚合函数。<br />\n <code>HAVING </code> 子句：在分组和聚合之后筛选记录，通常包含聚合函数。</p>\n</div></details>\n<details class=\"success\"><summary>HashMap的底层实现</summary><div>\n<p><code>HashMap</code>  是 Java 中常用的数据结构，它的底层实现主要依赖于数组和链表。在 Java 8 及之后的版本中，还引入了红黑树来优化性能。以下是  <code>HashMap</code>  的底层实现细节：</p>\n<h3 id=\"1-数据存储结构\"><a class=\"anchor\" href=\"#1-数据存储结构\">#</a> 1. 数据存储结构</h3>\n<p><code>HashMap</code>  使用一个数组来存储数据，每个数组元素称为一个 “桶”（bucket）。每个桶中存储的是一个链表或红黑树的头节点。</p>\n<h3 id=\"2-哈希函数\"><a class=\"anchor\" href=\"#2-哈希函数\">#</a> 2. 哈希函数</h3>\n<p>当我们向  <code>HashMap</code>  中插入一个键值对时，首先会对键进行哈希运算，得到一个哈希值。然后通过哈希值计算出该键值对应该存储在数组中的哪个位置（即哪个桶中）。计算位置的公式通常是  <code>index = hash % array.length</code> 。</p>\n<h3 id=\"3-解决哈希冲突\"><a class=\"anchor\" href=\"#3-解决哈希冲突\">#</a> 3. 解决哈希冲突</h3>\n<p>哈希冲突是指不同的键经过哈希运算后得到相同的数组索引。 <code>HashMap</code>  通过链表和红黑树来解决哈希冲突：</p>\n<ul>\n<li><strong>链表</strong>：在 Java 8 之前，当发生哈希冲突时， <code>HashMap</code>  会将冲突的键值对存储在同一个桶中的链表中。</li>\n<li><strong>红黑树</strong>：在 Java 8 及之后的版本中，当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，以提高查询效率。</li>\n</ul>\n<h3 id=\"4-扩容机制\"><a class=\"anchor\" href=\"#4-扩容机制\">#</a> 4. 扩容机制</h3>\n<p><code>HashMap</code>  有一个负载因子（默认是 0.75），当  <code>HashMap</code>  中的元素数量超过  <code>容量 * 负载因子</code>  时， <code>HashMap</code>  会进行扩容。扩容时， <code>HashMap</code>  会创建一个新的、更大的数组，并将原数组中的所有元素重新哈希并放入新数组中。</p>\n<h3 id=\"5-主要方法\"><a class=\"anchor\" href=\"#5-主要方法\">#</a> 5. 主要方法</h3>\n<ul>\n<li><code>put(K key, V value)</code> ：将键值对插入  <code>HashMap</code>  中。如果键已经存在，则更新对应的值。</li>\n<li><code>get(Object key)</code> ：根据键获取对应的值。</li>\n<li><code>remove(Object key)</code> ：根据键移除对应的键值对。</li>\n<li><code>containsKey(Object key)</code> ：判断  <code>HashMap</code>  中是否包含指定的键。</li>\n</ul>\n<h3 id=\"6-示例代码\"><a class=\"anchor\" href=\"#6-示例代码\">#</a> 6. 示例代码</h3>\n<p>以下是  <code>HashMap</code>  中节点的实现示例：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> <span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key <span class=\"token operator\">+</span> <span class=\"token string\">\"=\"</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token class-name\">V</span> oldValue <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        value <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>o<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></div></details>\n<details class=\"success\"><summary>虚拟内存技术</summary><div>\n<p>虚拟内存是计算机系统中的一种内存管理技术，它使得应用程序可以使用比实际物理内存更大的内存空间。虚拟内存通过将物理内存和磁盘存储结合起来，为每个进程提供一个独立的、连续的地址空间。以下是虚拟内存的主要概念和工作原理：</p>\n<h3 id=\"1-基本概念\"><a class=\"anchor\" href=\"#1-基本概念\">#</a> 1. 基本概念</h3>\n<ul>\n<li><strong>虚拟地址空间</strong>：每个进程都有一个独立的虚拟地址空间，这个地址空间是连续的，并且对进程来说是唯一的。</li>\n<li><strong>物理内存</strong>：实际存在的内存硬件，通常是 RAM（随机存取存储器）。</li>\n<li><strong>页面（Page）</strong>：虚拟内存和物理内存都被划分成固定大小的块，称为页面。常见的页面大小是 4KB。</li>\n<li><strong>页表（Page Table）</strong>：操作系统维护的一个数据结构，用于映射虚拟地址到物理地址。</li>\n</ul>\n<h3 id=\"2-工作原理\"><a class=\"anchor\" href=\"#2-工作原理\">#</a> 2. 工作原理</h3>\n<ul>\n<li><strong>地址转换</strong>：当进程访问内存时，CPU 会将虚拟地址转换为物理地址。这个转换过程由内存管理单元（MMU）完成，MMU 使用页表来查找对应的物理地址。</li>\n<li><strong>页面置换</strong>：当物理内存不足时，操作系统会将不常用的页面暂时存储到磁盘上（称为交换空间或页面文件），并将需要的页面加载到物理内存中。这种过程称为页面置换。</li>\n<li><strong>缺页中断</strong>：当进程访问的页面不在物理内存中时，会触发缺页中断。操作系统会处理这个中断，将所需页面从磁盘加载到内存中。</li>\n</ul>\n<h3 id=\"3-优点\"><a class=\"anchor\" href=\"#3-优点\">#</a> 3. 优点</h3>\n<ul>\n<li><strong>扩展内存容量</strong>：虚拟内存使得应用程序可以使用比实际物理内存更大的内存空间。</li>\n<li><strong>内存保护</strong>：每个进程都有独立的虚拟地址空间，防止进程之间的内存访问冲突，提高系统稳定性和安全性。</li>\n<li><strong>内存管理灵活性</strong>：操作系统可以更灵活地管理内存，优化内存使用效率。</li>\n</ul>\n<h3 id=\"4-示例\"><a class=\"anchor\" href=\"#4-示例\">#</a> 4. 示例</h3>\n<p>假设一个系统有 4GB 的物理内存，但通过虚拟内存技术，可以让每个进程使用高达 16GB 的虚拟内存。当一个进程需要访问超过物理内存容量的数据时，操作系统会将不常用的数据页面存储到磁盘上，并将需要的数据页面加载到物理内存中。</p>\n<h3 id=\"5-实际应用\"><a class=\"anchor\" href=\"#5-实际应用\">#</a> 5. 实际应用</h3>\n<p>虚拟内存广泛应用于现代操作系统中，如 Windows、Linux 和 macOS。它使得系统能够运行大型应用程序，并提高系统的稳定性和安全性。</p>\n</div></details>\n<details class=\"success\"><summary>单例模式</summary><div>\n<p>单例模式（Singleton Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。以下是几种常见的单例模式实现方法：</p>\n<h3 id=\"1-饿汉式eager-initialization\"><a class=\"anchor\" href=\"#1-饿汉式eager-initialization\">#</a> 1. 饿汉式（Eager Initialization）</h3>\n<p>在类加载时就创建实例，线程安全，但可能会造成资源浪费。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Singleton</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"2-懒汉式lazy-initialization\"><a class=\"anchor\" href=\"#2-懒汉式lazy-initialization\">#</a> 2. 懒汉式（Lazy Initialization）</h3>\n<p>在需要时才创建实例，非线程安全。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"3-线程安全的懒汉式thread-safe-lazy-initialization\"><a class=\"anchor\" href=\"#3-线程安全的懒汉式thread-safe-lazy-initialization\">#</a> 3. 线程安全的懒汉式（Thread-Safe Lazy Initialization）</h3>\n<p>使用同步方法确保线程安全，但性能较低。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"4-双重检查锁定double-checked-locking\"><a class=\"anchor\" href=\"#4-双重检查锁定double-checked-locking\">#</a> 4. 双重检查锁定（Double-Checked Locking）</h3>\n<p>结合了懒汉式和同步方法的优点，性能较好。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Singleton</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                    instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"5-静态内部类bill-pugh-singleton\"><a class=\"anchor\" href=\"#5-静态内部类bill-pugh-singleton\">#</a> 5. 静态内部类（Bill Pugh Singleton）</h3>\n<p>利用静态内部类的特性，既实现了延迟加载，又保证了线程安全。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// 私有构造函数，防止外部实例化</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonHelper</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Singleton</span> <span class=\"token constant\">INSTANCE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">SingletonHelper</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"6-枚举enum-singleton\"><a class=\"anchor\" href=\"#6-枚举enum-singleton\">#</a> 6. 枚举（Enum Singleton）</h3>\n<p>枚举类型是实现单例模式的最佳方法，天然支持序列化和线程安全。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 单例方法</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></div></details>\n",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "https://kagurazakaasahi.github.io/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "ES搜索的使用",
            "date_published": "2024-08-15T13:30:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>在实习过程中，有一个故事单需要完成，具体为将当前项目的全局搜索由只能搜索一个关键词改为能搜索用空格分隔的多个关键词。</p>\n<p>经阅读代码，该项目实现搜索是由 <code>Elastic Search</code>  简称 <code>ES</code>  的中间层完成的。</p>\n<h2 id=\"什么是es\"><a class=\"anchor\" href=\"#什么是es\">#</a> 什么是 ES</h2>\n<p><code>Elasticsearch </code> 是一个基于 <code>Lucene</code>  的开源搜索引擎，具有高扩展性和分布式特性。它可以实时地存储、搜索和分析大量数据。</p>\n<p>主要特点<br />\n分布式： <code>Elasticsearch</code>  可以扩展到上百台服务器，处理 PB 级别的数据。<br />\n高可用性：通过分片和副本机制，确保数据的高可用性和容错性。<br />\n近实时搜索：数据更新几乎是实时的，适用于需要快速响应的应用场景。<br />\n多种 API：提供  <code>RESTful API</code> ，便于集成和使用。<br />\n使用场景<br />\n全文搜索：适用于网站搜索、日志分析等需要快速检索的场景。<br />\n数据分析：结合  <code>Kibana</code> ，可以进行数据的可视化分析。<br />\n日志和事件数据处理：与  <code>Logstash </code> 配合， <code>形成 ELK（Elasticsearch, Logstash, Kibana）</code> 技术栈，用于日志和事件数据的收集、处理和分析。</p>\n<h2 id=\"如何使用es\"><a class=\"anchor\" href=\"#如何使用es\">#</a> 如何使用 ES</h2>\n<p><code>ES</code>  对外提供 <code>http</code>  接口，故所有语言均可使用。</p>\n<h2 id=\"注意事项\"><a class=\"anchor\" href=\"#注意事项\">#</a> 注意事项</h2>\n<p>由于 <code>ES</code>  搜索语句为 <code>JSON</code>  格式 (这种格式被称为 <code> Query DSL（Domain Specific Language）</code> ，它使用  <code>JSON</code>  来构建查询请求), 因此，如果在手动使用 <code>StringBuilder</code>  来构建 ES 语句，那么极大可能会出现遗漏逗号，闭括号的问题。这里推荐使用 <code>notepad++</code>  的插件进行 <code>JS</code>  格式化检查是否存在遗漏</p>\n<p><img data-src=\"/ES%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8/image-20240831123931994.png\" class=\"\" title=\"image-20240831123931994\"></p>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9lbGFzdGljc2VhcmNo\">Elasticsearch：官方分布式搜索和分析引擎 | Elastic</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTg5MTU2L2FydGljbGUvZGV0YWlscy8xMDc4MjY3NTI=\">ES（Elasticsearch）全文搜索引擎 (最全) 入门基本语法与在 SpringBoot 中的实战_springboot es 搜索语法 - CSDN 博客</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXliNDIxSjdvWC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT1mMTNjMDYxMWE0NzliYmQ0ZjlkMzM3NTBhNmZiZjdmZA==\">Elastic Search 是什么？Lucene 是什么？架构是怎么样的？_哔哩哔哩_bilibili</span></li>\n</ul>\n",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "url": "https://kagurazakaasahi.github.io/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
            "title": "单元测试",
            "date_published": "2024-08-01T04:00:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>在实习过程中，首先要熟悉所在组所做的项目，而单元测试就是一个比较好的方法。</p>\n<h2 id=\"什么是单元测试\"><a class=\"anchor\" href=\"#什么是单元测试\">#</a> 什么是单元测试</h2>\n<p>单元测试（ <code>Unit Testing</code> ）是软件开发中的一种测试方法，旨在验证代码中最小可测试单元（通常是函数、方法或类）的正确性。它的主要目的是确保每个单元在各种情况下都能按预期工作，从而及早发现和纠正错误。</p>\n<h3 id=\"单元测试的特点\"><a class=\"anchor\" href=\"#单元测试的特点\">#</a> 单元测试的特点</h3>\n<p>独立性：单元测试通常是独立的，不依赖于其他部分的代码。<br />\n自动化：单元测试可以通过自动化工具运行，减少人为错误。<br />\n快速反馈：由于测试范围小，单元测试能够快速提供反馈，帮助开发者及时修复问题。</p>\n<h3 id=\"单元测试的优点\"><a class=\"anchor\" href=\"#单元测试的优点\">#</a> 单元测试的优点</h3>\n<p>提高代码质量：通过早期发现和修复错误，单元测试可以显著提高代码质量。<br />\n简化调试：由于测试范围小，定位和修复错误变得更加容易。<br />\n文档作用：单元测试代码可以作为文档，帮助其他开发者理解代码的功能和使用方法。</p>\n<h2 id=\"如何进行单元测试\"><a class=\"anchor\" href=\"#如何进行单元测试\">#</a> 如何进行单元测试</h2>\n<h3 id=\"使用squaretest插件\"><a class=\"anchor\" href=\"#使用squaretest插件\">#</a> 使用 squareTest 插件</h3>\n<ul>\n<li>\n<p>安装插件</p>\n</li>\n<li>\n<p>找到要生成的类，点击 <code>generate Test</code></p>\n</li>\n<li>\n<p>更换给定的模板为以下文件中内容</p>\n</li>\n<li>\n<p>补充必备代码</p>\n<ul>\n<li>\n<p><code>Public Class xxx extends NecpBaseContextTest</code>  首先继承这个类</p>\n</li>\n<li>\n<p>添加以下静态代码块：</p>\n<pre><code class=\"language-Java\">static &#123;\n    (new SqlResource()).handleEvent(Database.MYSQL, null);\n    (new SqlResource()).handleEvent(Database.ORACLE, null);\n    &#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>注意事项<br />\n <code>tearDown() </code> 方法相当于回收垃圾的作用，其中 <code> reset</code>  方法参数只放被 <code>@Mock</code>  注解的对象， <code>@InjectMock</code>  不需要，如果整个测试类没有 <code>@Mock</code>  注解的对象，那么就不需要编写 <code>tearDown()</code>  方法。例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Mock</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">ArchivesCsRepository</span> mockArchivesCsRepository<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token annotation punctuation\">@After</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tearDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span>mockArchivesCsRepository<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"mockito框架用法要点\"><a class=\"anchor\" href=\"#mockito框架用法要点\">#</a> Mockito 框架用法要点</h3>\n<h4 id=\"参数匹配和打桩\"><a class=\"anchor\" href=\"#参数匹配和打桩\">#</a> 参数匹配和打桩</h4>\n<p>前言：<br />\n当你在测试中设置 <code>mock</code>  对象的行为（即打桩，使用 <code>when(...).thenReturn(...)</code>  等语句），你指定了当特定方法被特定参数调用时应该返回什么。<br />\n如果在实际执行测试时传递的参数与你设置的参数不匹配，那么打桩的行为将不会发生， <code>mock </code> 对象将返回默认值（如 <code> null</code> 、 <code>0 </code> 或  <code>false </code> 等）。</p>\n<p>例如：<br />\n--- 被测试方法片段 ---</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token constant\">ARCH_QUERY_DOCNO_SQL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>sql <span class=\"token operator\">=</span> <span class=\"token class-name\">MessageFormat</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">,</span> tableName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> param <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ArchMoveBO</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> moveQueryService<span class=\"token punctuation\">.</span><span class=\"token function\">findListByParam</span><span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">,</span> param <span class=\"token punctuation\">,</span> <span class=\"token class-name\">ArchMoveBO</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> result <span class=\"token operator\">||</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">return</span> <span class=\"token string\">\"T000001\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>---- 错误的测试方法片段 ----</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ArchMoveBO</span><span class=\"token punctuation\">></span></span> archMoveBOS <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>archMoveBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">when</span><span class=\"token punctuation\">(</span>queryService<span class=\"token punctuation\">.</span><span class=\"token function\">findListByParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sql\"</span><span class=\"token punctuation\">,</span>newHashMap<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> archMoveBO<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span>archMoveBOS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> result <span class=\"token operator\">=</span> archivesMoveQueryServiceUnderTest<span class=\"token punctuation\">.</span><span class=\"token function\">getNextProcessInstId</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"year\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>执行结果： 被测方法返回的 result 为 null，这就说明测试方法打桩失效了。<br />\n---- 正确的测试方法片段 ----</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ArchMoveBO</span><span class=\"token punctuation\">></span></span> archMoveBOS <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>archMoveBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">when</span><span class=\"token punctuation\">(</span>queryService<span class=\"token punctuation\">.</span><span class=\"token function\">findListByParam</span><span class=\"token punctuation\">(</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">anyMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span>archMoveBOS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> result <span class=\"token operator\">=</span> archivesMoveQueryServiceUnderTest<span class=\"token punctuation\">.</span><span class=\"token function\">getNextProcessInstId</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"year\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>执行结果： 被测方法返回的 <code>result</code>  为 <code>archMoveBOS</code> ，这就说明测试方法打桩成功了。</p>\n<p>结论： 当使用 <code>mock</code>  来 <code>mock</code>  方法的时候，一定要注意参数匹配， 否则打桩不成功。</p>\n<p>补充： 在使用参数任意匹配符时，也要注意匹配，有的时候 <code>Any()</code>  可以成功，但是有的时候需要具体匹配，比如使用 <code>anyString()</code> ;</p>\n<h4 id=\"如何测试private方法\"><a class=\"anchor\" href=\"#如何测试private方法\">#</a> 如何测试 private 方法？</h4>\n<p>(1) 使用这个方法 <code>Whitebox.invokeMethod()</code>  调用私有方法即可。<br />\n例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Whitebox</span><span class=\"token punctuation\">.</span><span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span>archivesPrintQueryService<span class=\"token punctuation\">,</span> <span class=\"token string\">\"isPrintEleOrOther\"</span><span class=\"token punctuation\">,</span> nodeTypeCodeMap<span class=\"token punctuation\">,</span> isVoucher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意点：<br />\n(1) 使用 <code>Whitebox</code>  调用私有方法时不能 <code>debug</code>  调试。<br />\n(2) 一定要注意方法的返回值，如果返回值不对应就会报错，但是这个错是运行时的错误，不会在编译的时候爆出来，一旦出错难以找出，一定要小心。<br />\n在 <code>Java</code>  中， <code>Whitebox</code>  类通常来自于 <code>org.jmockit.whitebox</code>  包，它是 <code>Mockit</code>  框架的一部分，用于测试时访问私有方法。 <code>Whitebox.invokeMethod()</code>  方法用于调用一个类的私有方法，即使这些方法不是公开的，也可以通过反射机制来访问它们。<br />\n下面是 <code>Whitebox.invokeMethod()</code>  方法的签名：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> methodName<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> parameterTypes<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> parameters<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><code>archivesPrintQueryService</code> : 这是你要调用私有方法的对象实例。在这个例子中，它是一个实现了 <code>archivesPrintQueryService</code>  接口或类的实例。<br />\n&quot; <code>isPrintEleOrOther</code> &quot;: 这是你要调用的私有方法的名称。在这个字符串中，方法名是 <code>isPrintEleOrOther</code> ，注意，方法名不需要加任何修饰符，即使是私有方法。<br />\n <code>nodeTypeCodeMap</code> : 这是第一个参数传递给 <code>isPrintEleOrOther</code>  方法的值。 <code>nodeTypeCodeMap</code>  通常是一个映射（如 <code>HashMap</code>  或 <code>Map</code> ），它包含了节点类型代码和其它相关数据的键值对。<br />\n <code>isVoucher</code> : 这是第二个参数传递给 <code>isPrintEleOrOther</code>  方法的值。这个参数通常是布尔值，表示是否是凭证（ <code>isVoucher</code>  为 <code>true</code>  表示是凭证，为 false 表示不是）。<br />\n下面是如何使用 <code>Whitebox.invokeMethod()</code>  调用的详细步骤：</p>\n<ul>\n<li><code>archivesPrintQueryService</code>  对象是一个包含私有方法 <code>isPrintEleOrOther</code>  的类的实例。</li>\n<li><code>Whitebox.invokeMethod()</code>  被用来调用这个实例的私有方法 <code>isPrintEleOrOther</code> 。</li>\n<li><code>nodeTypeCodeMap</code>  和 <code>isVoucher</code>  作为参数传递给这个私有方法。</li>\n<li>私有方法 <code>isPrintEleOrOther</code>  执行其逻辑，可能基于传入的参数。</li>\n<li>执行结果是一个 <code>boolean[]</code>  数组，这个数组被赋值给 <code>result</code>  变量。</li>\n<li>总结一下， <code>Whitebox.invokeMethod()</code>  调用了 <code>archivesPrintQueryService</code>  对象的私有方法 <code>isPrintEleOrOther</code> ，并传递了两个参数 <code>nodeTypeCodeMap</code>  和 <code>isVoucher</code> ，然后返回了一个 <code>boolean[]</code>  类型的值，这个值被存储在 <code>result</code>  变量中。</li>\n</ul>\n<h4 id=\"如何测试static方法\"><a class=\"anchor\" href=\"#如何测试static方法\">#</a> 如何测试 static 方法</h4>\n<p>(1) 添加 <code>@PrepareForTest(Class.class)</code>  注解<br />\n (2) 模拟 <code>static</code>  方法：  <code>PowerMockito.mockStatic(ClassWithstaticMethod.class)</code> <br />\n(3) 定义 <code>static</code>  方法的行为：  <code>when().thenReturn()</code> ;</p>\n<p>注意点：如果出现问题，比如 not prepared for test.<br />\n 可能是 <code>PowerMockito</code>  和 <code>Mockito</code>  版本兼容性问题。</p>\n<h4 id=\"如何mock被测试类的方法中调用的方法\"><a class=\"anchor\" href=\"#如何mock被测试类的方法中调用的方法\">#</a> 如何 Mock 被测试类的方法中调用的方法</h4>\n<p>无需 <code>mock</code> ，直接陷入调用的方法即可。</p>\n<h4 id=\"如何设置待测方法的属性值\"><a class=\"anchor\" href=\"#如何设置待测方法的属性值\">#</a> 如何设置待测方法的属性值</h4>\n<p>例如： <code> @Value(&quot;$&#123;formatFileTagLimit:10000&#125;&quot;)</code> <br />\n <code>private Integer formatFileTagLimit;</code></p>\n<p>解决： 我们可以通过反射来进行属性注入。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Before</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">ReflectionTestUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">setField</span><span class=\"token punctuation\">(</span>archFormatFileTagServiceUnderTest<span class=\"token punctuation\">,</span> <span class=\"token string\">\"formatFileTagLimit\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"thisgetdao为null的解决办法\"><a class=\"anchor\" href=\"#thisgetdao为null的解决办法\">#</a> this.getDao () 为 NULL 的解决办法</h4>\n<p>以 <code>ArchivesDepotQueryServiceTest </code> 类为例子：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@InjectMocks</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">ArchivesDepotQueryService</span> service<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token annotation punctuation\">@Mock</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">ArchivesDepotRepository</span> repository<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token annotation punctuation\">@Before</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token class-name\">MockitoAnnotations</span><span class=\"token punctuation\">.</span><span class=\"token function\">initMocks</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token class-name\">Field</span> daoField <span class=\"token operator\">=</span> <span class=\"token class-name\">GeneralContext</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredField</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dao\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>daoField<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>daoField<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">,</span> repository<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>解释（通义灵码生成）：<br />\n这段标红代码的作用是通过反射机制，修改 <code>GeneralContext</code>  类中 <code>dao</code>  字段的值为 <code>repository</code> 。具体步骤如下：<br />\n(1) 使用 <code>getDeclaredField</code>  方法获取 <code>GeneralContext</code>  类中名为 <code>dao</code>  的私有字段；<br />\n(2) 调用 <code>setAccessible</code>  方法将该字段的访问权限设置为可访问；<br />\n(3) 使用 <code>set</code>  方法将 <code>dao</code>  字段的值设置为 <code>repository</code> ，并将 <code>service</code>  对象作为参数传入，表示要修改的是 <code>service</code>  对象中的 <code>dao</code>  字段值。</p>\n<h4 id=\"如何解决微服务调用的问题\"><a class=\"anchor\" href=\"#如何解决微服务调用的问题\">#</a> 如何解决微服务调用的问题</h4>\n<p>以 <code>ArchivesAttachServiceTest</code>  类为例：<br />\n步骤：<br />\n(1) 加入 <code>@PrepareForTest(&#123;MappService.class&#125;)</code> <br />\n(2) 对 <code>MapperService</code>  进行 <code>mock</code>  注入</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Mock</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">MappService</span> mappService<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>(3) 在 <code>setUp()</code>  方法中添加如下代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Before</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">Whitebox</span><span class=\"token punctuation\">.</span><span class=\"token function\">setInternalState</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MappService</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"INSTANCE\"</span><span class=\"token punctuation\">,</span> mappService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">when</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MappService</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">.</span><span class=\"token function\">doPost</span><span class=\"token punctuation\">(</span><span class=\"token function\">anyString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">anyMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">eq</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">anyObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>缺陷：<br />\n虽然 <code>mock</code>  成功，不会报错，但是不能设定返回值， <code>eturn</code>  为”” 空的。</p>\n<h4 id=\"解决dbutilisoracle-报错的方式\"><a class=\"anchor\" href=\"#解决dbutilisoracle-报错的方式\">#</a> 解决 DBUtil.isOracle () 报错的方式</h4>\n<p>（1） 在 <code>@PrepareForTest(DBUtil.class)</code>  中添加 <code>DBUtil.class</code></p>\n<p>（2）在相应的方法中添加这两句即可</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">PowerMockito</span><span class=\"token punctuation\">.</span><span class=\"token function\">mockStatic</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DBUtil</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">PowerMockito</span><span class=\"token punctuation\">.</span><span class=\"token function\">when</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DBUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">isOracle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"解决静态常量为空的情况\"><a class=\"anchor\" href=\"#解决静态常量为空的情况\">#</a> 解决静态常量为空的情况</h4>\n<p>例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">PowerMockito</span><span class=\"token punctuation\">.</span><span class=\"token function\">mockStatic</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SQLConst</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> <span class=\"token class-name\">PowerMockito</span><span class=\"token punctuation\">.</span><span class=\"token function\">field</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SQLConst</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"QYVO_STA_MITEM_SY_MCOM_SITEM\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>field<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"your_sql_query_here\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"让某个方法什么也不做从而跳过该方法\"><a class=\"anchor\" href=\"#让某个方法什么也不做从而跳过该方法\">#</a> 让某个方法什么也不做，从而跳过该方法</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">doNothing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">when</span><span class=\"token punctuation\">(</span>spy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">saveList</span><span class=\"token punctuation\">(</span><span class=\"token function\">anyList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"已知会抛出某个异常\"><a class=\"anchor\" href=\"#已知会抛出某个异常\">#</a> 已知会抛出某个异常.</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>jupiter<span class=\"token punctuation\">.</span>api<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Test</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token keyword\">static</span> <span class=\"token import static\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>jupiter<span class=\"token punctuation\">.</span>api<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Assertions</span><span class=\"token punctuation\">.</span><span class=\"token static\">assertThrows</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">Exception</span> exception <span class=\"token operator\">=</span> <span class=\"token function\">assertThrows</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 在这里调用可能抛出 NullPointerException 的方法</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">CommentSaveStatusEnum</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"使用when来抛出异常\"><a class=\"anchor\" href=\"#使用when来抛出异常\">#</a> 使用 when 来抛出异常</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">when</span><span class=\"token punctuation\">(</span>mockSystemParamContext<span class=\"token punctuation\">.</span><span class=\"token function\">findByNameAndTenantGid</span><span class=\"token punctuation\">(</span><span class=\"token function\">anyString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">anyString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenThrow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error fetching parameter\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "学习"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--JVM/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--JVM/",
            "title": "八股文概要--JVM",
            "date_published": "2024-04-13T15:00:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"java继承时父子类的初始化顺序是怎样的\"><a class=\"anchor\" href=\"#java继承时父子类的初始化顺序是怎样的\">#</a> JAVA 继承时父子类的初始化顺序是怎样的</h2>\n<p>具体顺序如下</p>\n<ol>\n<li>父类 -- 静态变量</li>\n<li>父类 -- 静态初始化块</li>\n<li>子类 -- 静态变量</li>\n<li>子类 -- 静态初始化块</li>\n<li>父类 -- 变量</li>\n<li>父类 -- 初始化块</li>\n<li>父类 -- 构造器</li>\n<li>子类 -- 变量</li>\n<li>子类 -- 初始化块</li>\n<li>子类 -- 构造器</li>\n</ol>\n<p>总结如下：静态优于非静态，父类优于子类，变量优于初始化块优于构造器</p>\n<h2 id=\"jvm的双亲委派模型\"><a class=\"anchor\" href=\"#jvm的双亲委派模型\">#</a> JVM 的双亲委派模型</h2>\n<p>为什么设计，有何好处</p>\n<ol>\n<li>确保安全，避免 JAVA 核心类库被修改</li>\n<li>避免重复加载</li>\n<li>保证类的唯一性</li>\n</ol>\n<p>可以打破双亲委派模型吗？如何打破？</p>\n<p>可以。自定义一个类加载器，重写其中的 <code>loadClass</code>  方法，使其不进行双亲委派即可</p>\n<h2 id=\"什么是内存溢出什么是内存泄露\"><a class=\"anchor\" href=\"#什么是内存溢出什么是内存泄露\">#</a> 什么是内存溢出，什么是内存泄露</h2>\n<p>内存溢出：指程序申请内存时，没有足够的内存空间供其使用，抛出 <code>OutOfMemory</code></p>\n<p>内存泄露：指程序运行后，没有释放所占用的内存空间，一次泄露没有太大问题，长时间内存泄露会导致可用内存减少，最终导致内存溢出</p>\n<h2 id=\"线上项目jvm怎么设置\"><a class=\"anchor\" href=\"#线上项目jvm怎么设置\">#</a> 线上项目 JVM 怎么设置</h2>\n<p>假设线上 4 核 8G 机器</p>\n<p>JVM: 栈，堆，元空间</p>\n<ol>\n<li>栈：1m,-xss512k (改为 512k), 一个线程是 1m, 一个线上项目 Tomcat 可能有 300 个线程，300m;</li>\n<li>堆：大概把机器一半的内存给堆 (新生代，老年代)</li>\n<li>元空间：一般 512M 够用</li>\n</ol>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Thread/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Thread/",
            "title": "八股文概要--Thread",
            "date_published": "2024-04-13T14:50:32.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"threadlocal底层如何实现\"><a class=\"anchor\" href=\"#threadlocal底层如何实现\">#</a> ThreadLocal 底层如何实现</h2>\n<p>...</p>\n<h2 id=\"threadlocal为什么会内存泄露\"><a class=\"anchor\" href=\"#threadlocal为什么会内存泄露\">#</a> ThreadLocal 为什么会内存泄露</h2>\n<p>ThreadLocal 是一个类似 HashMap 的数据结构</p>\n<p>ThreadLocal 的实现原理就是通过 set 把 value set 到线程的 threadlocals 属性中，threadlocals 是一个 Map, 其中 key 是 ThreadLocal 的 this 引用，value 是我们 set 的值</p>\n<h2 id=\"sleep和wait有何区别\"><a class=\"anchor\" href=\"#sleep和wait有何区别\">#</a> sleep () 和 wait () 有何区别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">sleep()</th>\n<th style=\"text-align:left\">wait()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">所属类不同</td>\n<td style=\"text-align:left\">Thread</td>\n<td style=\"text-align:left\">Object</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">方法类型不同</td>\n<td style=\"text-align:left\">静态方法</td>\n<td style=\"text-align:left\">实例方法</td>\n</tr>\n<tr t.wait(time)=\"\">\n<td style=\"text-align:left\">使用语法不同</td>\n<td style=\"text-align:left\">thread.sleep(time)</td>\n<td style=\"text-align:left\">得先拿到锁 synchronize (t)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">唤醒方式不同</td>\n<td style=\"text-align:left\">必须传时间 time</td>\n<td style=\"text-align:left\">t.notify</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">释放锁资源不同</td>\n<td style=\"text-align:left\">不释放锁资源 (单纯为了让线程等待)</td>\n<td style=\"text-align:left\">释放锁资源 (协调线程同步)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">线程状态不同</td>\n<td style=\"text-align:left\">TIMED_WAITTING</td>\n<td style=\"text-align:left\">WAITTING</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"多个线程如何保证按顺序执行\"><a class=\"anchor\" href=\"#多个线程如何保证按顺序执行\">#</a> 多个线程如何保证按顺序执行</h2>\n<ol>\n<li>通过 join () 方法使当前线程 &quot;阻塞&quot;, 等待指定线程执行完毕后继续执行；</li>\n<li>通过创建单一化线程池 newSingleThreadExecutor () 实现</li>\n<li>通过倒数计时器 CountDownLatch 实现</li>\n<li>使用 Object 的 wait/notify 方法实现</li>\n<li>使用线程的 Condition (条件变量) 方法实现</li>\n<li>使用线程的 CyclicBarrier (回环栅栏) 方法实现</li>\n<li>使用线程的 Semaphore (信号量) 方法实现</li>\n</ol>\n<h2 id=\"java线程池中submit和execute方法有何区别\"><a class=\"anchor\" href=\"#java线程池中submit和execute方法有何区别\">#</a> JAVA 线程池中 submit () 和 execute () 方法有何区别</h2>\n<ol>\n<li>两个方法都可以向线程池中提交任务</li>\n<li>execute 只能提交 Runnable, 无返回值</li>\n<li>submit 既可以提交 Runnable, 返回值为 null, 也可以提交 Callable, 返回值 Future</li>\n<li>execute () 方法定义在 Executor 接口中</li>\n<li>submit () 方法定义在 ExecutorService 接口中</li>\n<li>execute 执行任务遇到异常会直接抛出</li>\n<li>submit 执行任务时遇到异常不会直接抛出，只有调用 Future 的 get () 方法获取返回值时，才会抛出异常</li>\n</ol>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--HashMap/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--HashMap/",
            "title": "八股文概要--HashMap",
            "date_published": "2024-04-13T13:47:23.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"hashmap底层如何实现\"><a class=\"anchor\" href=\"#hashmap底层如何实现\">#</a> HashMap 底层如何实现</h2>\n<p><img data-src=\"C:%5CUsers%5CKagurazakaAsahi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240413214834288.png\" alt=\"image-20240413214834288\" /></p>\n<p>以上为整体类继承结构</p>\n<ol>\n<li>\n<p>主要特点</p>\n<ul>\n<li>\n<p>数据以键值 (kay-value) 对方式储存的一个集合容器</p>\n</li>\n<li>\n<p>key 不重复</p>\n</li>\n<li>\n<p>可以使用 null 的键和 null 的值</p>\n</li>\n<li>\n<p>不保证 key-value 映射的顺序</p>\n</li>\n<li>\n<p>非线程安全实现</p>\n</li>\n</ul>\n</li>\n<li>\n<p>数据结构</p>\n<ul>\n<li>JDK1.7: 数组 + 链表</li>\n<li>JDK1.8: 数组 + 链表 + 红黑树</li>\n</ul>\n</li>\n<li>\n<p>HashMap 性能参数 q</p>\n<ul>\n<li>初始容量 capacity: 创建数组的长度默认是 16, 如果太少，很容易触发扩容，如果太多，遍历数组会比较慢</li>\n<li>负载因子 loadFactor: 一个衡量的尺度，数组长度达到多少的时候触发数组自动扩容，默认为 0.75</li>\n<li>阈值 threshold: <code>阈值=容量*负载因子</code> ，默认 <code>16*0.75=12</code> , 当元素数量超过阈值时触发扩容</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"多线程条件下hashmap有什么问题吗\"><a class=\"anchor\" href=\"#多线程条件下hashmap有什么问题吗\">#</a> 多线程条件下 HashMap 有什么问题吗</h2>\n<ol>\n<li>多线程条件下会导致死循环的问题，导致 CPU100%</li>\n<li>多线程 put 可能导致元素丢失</li>\n<li>put 和 get 并发时，可能导致 get 为 null</li>\n</ol>\n<h2 id=\"hashmap链表节点过深时为什么选择使用红黑树\"><a class=\"anchor\" href=\"#hashmap链表节点过深时为什么选择使用红黑树\">#</a> HashMap 链表节点过深时为什么选择使用红黑树</h2>\n<p>该问题要根据二叉树的特性来回答</p>\n<p>二叉查找树</p>\n<p>强平衡二叉查找树</p>\n<p>弱平衡二叉查找树</p>\n<p>红黑树</p>\n<h2 id=\"什么是hash碰撞发射hash碰撞怎么办\"><a class=\"anchor\" href=\"#什么是hash碰撞发射hash碰撞怎么办\">#</a> 什么是 hash 碰撞，发射 hash 碰撞怎么办</h2>\n<p>定义：对于不同的关键字，可能得到同一个 hash 地址，即 key1!=key2 而 f (key1) == f (key2), 对于这种现象称之为 hash 碰撞，也叫 hash 冲突</p>\n<p>一般 hash 冲突只能尽量地减少，无法完全避免，因为关键字在理论上可以有无限多个，而用来储存这些关键字的数组容量有限的，所以就必然会导致 hash 冲突，只能通过选择合适的 hash 函数来降低发生 hash 冲突的概率</p>\n<p>具体解决办法</p>\n<ul>\n<li>开放地址法：当发生 hash 冲突的时候，按照某种方法继续探测 hash 表中其他储存位置，一直找到空位置为止</li>\n<li>再 hash 法：发生冲突时再次 hash, 直到没有冲突</li>\n<li>链地址法 (HashMap 采用的方法): 当发生 hash 冲突时，以链表的方式储存冲突元素，插入方式头插尾插均可.(虽然该方法是一种不错的解决方式，但也存在一些明显的弊端，在极端情况下，查询的时间还是会达到 O (n) 级别，此时哈希表退化成普通链表，此时查找元素，时间复杂度为 O (n). 因此，在链表达到一定长度后，把链表转化为一棵树可以提高查找效率，HashMap 源码中就是这么实现的。当数组长度大于 64, 且数组某个位置上的链表长度大于 8 时，就会把数组某个位置上的链表转换为一棵红黑树)</li>\n</ul>\n<h2 id=\"concurrenthashmap底层如何实现\"><a class=\"anchor\" href=\"#concurrenthashmap底层如何实现\">#</a> ConcurrentHashMap 底层如何实现</h2>\n<p>在 JDK1.7 和 JDK1.8 实现方式不同</p>\n<ul>\n<li>1.7: 数据结构为 Segment [] 数组 + HashEntry [] 数组 +; 链表，Segment 继承 ReentrantLock, 采用分段锁 (默认 16 把锁), 每一把锁只锁一个 Segment</li>\n<li>1.8: 数据结构为 Node [] 数组 + 链表 + 红黑树，初始化 Node 数组采用 CAS+volatile; 放数据时采用 synchronize</li>\n</ul>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--MyBatis/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--MyBatis/",
            "title": "八股文概要--MyBatis",
            "date_published": "2024-04-12T15:39:44.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"mybatis框架如何实现分页\"><a class=\"anchor\" href=\"#mybatis框架如何实现分页\">#</a> MyBatis 框架如何实现分页</h2>\n<p>分页分为两种</p>\n<ul>\n<li>逻辑分页：将所有数据查出来，再在内存中进行分页处理</li>\n<li>物理分页：直接在数据库中进行分页</li>\n</ul>\n<p>具体实现:</p>\n<ul>\n<li>自己写 SQL 进行分页 (物理)</li>\n<li>使用拦截器进行分页 (物理)</li>\n<li>使用 PageHelper 进行分页 (物理)</li>\n<li>使用 RowBounds 进行分页 (逻辑)</li>\n</ul>\n<h2 id=\"mybatis框架里面的缓存机制\"><a class=\"anchor\" href=\"#mybatis框架里面的缓存机制\">#</a> MyBatis 框架里面的缓存机制</h2>\n<p>MyBatis 中有两级缓存：一级缓存，二级缓存 (都是 HashMap)</p>\n<p>一级缓存失效的几种情况</p>\n<ul>\n<li>不同的 SqlSession 对应不同的一级缓存</li>\n<li>同一个 SqlSession 但是查询条件不同</li>\n<li>同一个 SqlSession 两次查询期间执行了任何一次增删改操作</li>\n<li>同一个 SqlSession 两次查询期间手动清空了缓存</li>\n</ul>\n<p>二级缓存</p>\n<p>在 SqlSession 关闭 (即 DAO 操作) 后将内容写入二级缓存</p>\n<p>二级缓存默认关闭，开启二级缓存，需要同时有如下两项</p>\n<pre><code>application.yml\n\tmybatis:\n\t\tconfiguration:\n\t\t\tcache-enable:true\nMapper.xml\n&lt;cache/&gt;\n</code></pre>\n<p>二级缓存是跨 SqlSession, 多个 SqlSession 可以共用同一个二级缓存；</p>\n<p>二级缓存是 mapper 级别的缓存，根据 mapper 的 namespace 区分，两个 mapper 的 namespace 相同</p>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "title": "八股文概要--线程池",
            "date_published": "2024-04-12T15:04:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"java线程池有哪些核心参数分别有什么作用\"><a class=\"anchor\" href=\"#java线程池有哪些核心参数分别有什么作用\">#</a> java 线程池有哪些核心参数，分别有什么作用</h2>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ThreadPoolExecutor</span> threadPoolExecutor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//corePoolSize 线程池中的核心线程数量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token number\">16</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//maximumPoolSize</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token number\">60</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//keepAliveTime</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//keepAlive 的时间单位</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 任务队列</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">defaultThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 线程工厂，用来创建线程，一般采用默认，也可自定义实现</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor<span class=\"token punctuation\">.</span>CallerRunsPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 拒绝策略 (当 corePoolSize 正在执行 /workQueue 已满 / 线程数达 maximumPoolSize 需要拒绝新提交过来的事务)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>构造方法最多的是七个参数 3</p>\n<h2 id=\"线程池有哪些拒绝策略\"><a class=\"anchor\" href=\"#线程池有哪些拒绝策略\">#</a> 线程池有哪些拒绝策略</h2>\n<p>JDK 提供了四种内置的拒绝策略</p>\n<ul>\n<li>AbortPolicy (默认): 丢弃任务并抛出 RejectedExecutionException 异常</li>\n<li>DiscardPolicy: 直接丢弃任务，不抛出异常，没有任何提示</li>\n<li>DiscardOldestPolicy: 丢弃任务队列中最靠前的任务，当前提交的任务不会丢弃</li>\n<li>CallerRunsPolicy: 交由任务的调用线程 (提交任务的线程) 来执行任务</li>\n</ul>\n<p>除以上四种拒绝策略，还可以通过实现 RejectedExecutionHandler 接口，实现自定义的拒绝策略</p>\n<h2 id=\"说一说线程池的执行流程\"><a class=\"anchor\" href=\"#说一说线程池的执行流程\">#</a> 说一说线程池的执行流程</h2>\n<h2 id=\"线程池核心线程数该如何设置\"><a class=\"anchor\" href=\"#线程池核心线程数该如何设置\">#</a> 线程池核心线程数该如何设置</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi>N</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>×</mo><msub><mi>U</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>×</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>W</mi><mi mathvariant=\"normal\">/</mi><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N_{thread} =N_{cpu}\\times U_{cpu}\\times (1+W/C)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">h</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">u</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">u</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>Ncpu = cpu 的核心数，Ucpu = cpu 的使用率 (在 0~1 之间)</li>\n<li>W = 线程等待时间，C = 线程计算时间</li>\n</ul>\n<p>根据以上公式，可将任务分为 CPU 密集型和 IO 密集型</p>\n<h3 id=\"cpu密集型\"><a class=\"anchor\" href=\"#cpu密集型\">#</a> CPU 密集型</h3>\n<p>CPU 密集型：线程数 = CPU 核心数 + 1</p>\n<p>这种任务主要消耗 CPU 资源，比如加解密，压缩，计算等一系列需要大量耗费 CPU 资源的任务</p>\n<p>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间.</p>\n<h3 id=\"io密集型\"><a class=\"anchor\" href=\"#io密集型\">#</a> IO 密集型</h3>\n<p>线程数 = CPU 核心数 * 2</p>\n<p>这种任务会有大部分时间进行 IO 操作，比如想 MySQL 数据库，文件读写，网络通信等任务，这类任务不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多的时间</p>\n<p>线程在处理 IO 的时间段内不会占用 CPU, 这时就可以将 CPU 交出给其他线程使用，因此在 IO 密集型任务的应用中可以多配置一些线程</p>\n<hr />\n<p>因此核心线程数配置的数量参考 CPU 的运行，合理配置线程数量就可以最大限度的利用 CPU</p>\n<p>基本原则:</p>\n<ul>\n<li>线程执行时间越多，就需要越少的线程</li>\n<li>线程执行时间越少，就需要越多的线程</li>\n</ul>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Spring/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Spring/",
            "title": "八股文概要--Spring",
            "date_published": "2024-04-12T04:47:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"spring的bean是线程安全的吗\"><a class=\"anchor\" href=\"#spring的bean是线程安全的吗\">#</a> Spring 的 Bean 是线程安全的吗</h2>\n<p>不是</p>\n<p>Spring 容器中的 Bean 默认是 singleton 单例的，所有线程共享一个单例 Bean, 因此是存在资源竞争的；</p>\n<p>但在实际开发中，单例 Bean 一般都是以无状态的方式来使用，即线程之间的操作不会对 Bean 的成员执行除查询以外的操作，所以这个 Bean 又可以说是线程安全的。比如：Controller,Service,Dao 等这些 Bean 大多数是无状态的，我们不会对这些 Bean 中的属性进行修改操作，只需要关注方法本身即可；</p>\n<h2 id=\"如何保证spring容器中bean是线程安全的\"><a class=\"anchor\" href=\"#如何保证spring容器中bean是线程安全的\">#</a> 如何保证 Spring 容器中 Bean 是线程安全的</h2>\n<ul>\n<li>把默认的 singleton 单例的 Bean 改为 prototype 多例的 Bean</li>\n<li>在 Bean 对象中避免定义可变的成员变量</li>\n<li>如果 Bean 对象中需要定义可变成员变量，将可变成员变量保存在 ThreadLocal 中；</li>\n</ul>\n<h2 id=\"什么情况下会触发spring事务回滚\"><a class=\"anchor\" href=\"#什么情况下会触发spring事务回滚\">#</a> 什么情况下会触发 Spring 事务回滚</h2>\n<p>在事务方法发生异常时触发</p>\n<h2 id=\"如果事务方法抛出ioexception是否会触发spring事务回滚\"><a class=\"anchor\" href=\"#如果事务方法抛出ioexception是否会触发spring事务回滚\">#</a> 如果事务方法抛出 IOException 是否会触发 Spring 事务回滚</h2>\n<ul>\n<li>如果采用 Spring 默认的事务回滚规则，它默认是发生 RuntimeException 异常时触发事务回滚，而现在是抛出 IOException 异常，那么不会触发 Spring 事务回滚</li>\n<li>如果想触发 IOException 异常事务回滚，需要指定回滚的规则</li>\n<li>@Transactional(rollbackFor = IOException.class)</li>\n</ul>\n<h2 id=\"什么情况下spring事务会失效\"><a class=\"anchor\" href=\"#什么情况下spring事务会失效\">#</a> 什么情况下 Spring 事务会失效</h2>\n<ul>\n<li>同一个 service 中，方法 a 标注事务注解，方法 b 没有标注事务注解 (a 有，b 没有)</li>\n<li>同一个 service 中，没有标注事务注解的 b 方法调用标注了事务注解的 a 方法 (无事务)</li>\n<li>不同的 Service 中，没有标注事务注解的 b 方法调用标注了事务注解的 a 方法 (有事务)</li>\n<li>标注了事务注解的 public 方法，protected 方法，默认无修饰方法，private 方法，final 方法，static 方法 (public 有效，其他均无效)</li>\n<li>多线程中的事务 (仅对当前线程有效，异步的新线程无效)</li>\n</ul>\n<p>具体情况如下</p>\n<ul>\n<li>异常类型错误</li>\n<li>方法或类上没有标注 @Transactional</li>\n<li>同一类中，方法内部自调用</li>\n<li>事务方法不是 public 的</li>\n<li>多线程调用</li>\n<li>异常被 try...catch</li>\n<li>手动抛了别的异常</li>\n<li>事务方法所在的 Bean 未被 Spring 容器管理</li>\n<li>方法的事务传播类型不支持事务</li>\n<li>表的数据库引擎不支持事务，比如 MyISAM 存储引擎不支持事务</li>\n</ul>\n<h2 id=\"spring框架bean的生命周期\"><a class=\"anchor\" href=\"#spring框架bean的生命周期\">#</a> Spring 框架 Bean 的生命周期</h2>\n<ol>\n<li>解析 xml 文件配置或者注解的类，得到 BeanDefinition</li>\n<li>通过 BeanDefinition 反射创建 Bean 对象 (实例化 Bean 对象)=-</li>\n<li>对 Bean 对象进行实例填充</li>\n<li>回调实现 Aware 接口的方法，如 BeanNameAware</li>\n<li>调用 BeanPostProcessor 的初始化前方法</li>\n<li>调用 init 初始化方法 (如果有的话)</li>\n<li>调用 BeanPostProcessor 的初始化后方法，此处会进行 AOP</li>\n<li>将创建好的 Bean 对象放入一个 Map 中</li>\n<li>业务中使用 Bean 对象就从 Map 中获取</li>\n<li>Spring 容器关闭时调用 DisposableBean 的 destory 方法销毁 Bean 对象</li>\n</ol>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Redis/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--Redis/",
            "title": "八股文概要--Redis",
            "date_published": "2024-04-11T10:55:23.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"redis应用场景\"><a class=\"anchor\" href=\"#redis应用场景\">#</a> Redis 应用场景</h2>\n<ul>\n<li>\n<p>缓存：热点数据 (经常查询，但不修改或删除数据) 首选 Redis 缓存，性能优秀</p>\n<ul>\n<li>\n<p>分布式锁：多个 tomcat 通过 Redis 获取锁后才能访问 MySQL 数据库</p>\n</li>\n<li>\n<p>实现方式：Jedis,Lettuce,RedisTemplete,Redisson (更加方便，无需额外写代码)</p>\n</li>\n<li>\n<p>具体实现</p>\n<ol>\n<li>获取锁:setnx key value</li>\n<li>设置锁过期时间:expire key 30</li>\n<li>执行业务代码</li>\n<li>释放锁: del key</li>\n</ol>\n</li>\n<li>\n<p>Redisson 实现分布式锁</p>\n<ol>\n<li>获取锁:redisson.getLock (&quot;lock&quot;);lock.lock ();</li>\n<li>执行业务代码</li>\n<li>释放锁:lock.unlock ();</li>\n</ol>\n</li>\n<li>\n<p>Redisson 实现的分布式锁是可重入的吗？</p>\n<p>可重入：即可重复获取，它指的是线程 T 获取到锁 A 之后，线程 T 再次获取锁 A 还是可以获取到的，java 中的 synchronized,ReentrantLock 都是可重入锁</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Token 存储</p>\n</li>\n<li>\n<p>短信验证码存储 (后端生成的验证码存入 Redis, 然后与用户发送的验证码进行比较)</p>\n</li>\n<li>\n<p>计数器</p>\n</li>\n<li>\n<p>全局唯一 ID</p>\n</li>\n<li>\n<p>排行榜 (使用 ZSet 结构)</p>\n</li>\n<li>\n<p>限流</p>\n</li>\n<li>\n<p>购物车</p>\n</li>\n<li>\n<p>点赞关注</p>\n</li>\n</ul>\n<h2 id=\"实现分布式锁需要注意哪些问题\"><a class=\"anchor\" href=\"#实现分布式锁需要注意哪些问题\">#</a> 实现分布式锁需要注意哪些问题</h2>\n<ul>\n<li>\n<p>不是原子操作 (即必须将获取锁和设置锁的过期时间变成一个整体进行操作)</p>\n</li>\n<li>\n<p>没有释放锁 (没有 del 锁，导致后面的线程无法拿到锁，当然如果设置了过期时间，还可以等过期时间结束)</p>\n</li>\n<li>\n<p>释放了锁，但业务还未执行完毕 (即执行业务代码耗时超过了锁的过期时间)</p>\n</li>\n<li>\n<p>释放了别人的锁 (因锁的过期时间过短，导致他人拿到自己的锁，而通过释放锁的操作将他人拿到的锁释放，解决方法为在释放锁时加入判断是否是自己的锁)</p>\n</li>\n<li>\n<p>大量请求竞争锁失败</p>\n<p>解决方法</p>\n<ol>\n<li>重试 (重试三到五次，若未拿到锁，返回获取锁失败)</li>\n<li>让业务流程尽可能短</li>\n<li>限流</li>\n</ol>\n</li>\n<li>\n<p>多节点 Redis 主从复制的问题</p>\n</li>\n<li>\n<p>锁的性能问题 (采用分段锁的方式，减少获取锁的排队时间)</p>\n</li>\n<li>\n<p>锁的可重入性</p>\n</li>\n</ul>\n<h2 id=\"采用redis缓存遇到缓存穿透缓存击穿缓存雪崩怎么办\"><a class=\"anchor\" href=\"#采用redis缓存遇到缓存穿透缓存击穿缓存雪崩怎么办\">#</a> 采用 Redis 缓存，遇到缓存穿透，缓存击穿，缓存雪崩怎么办？</h2>\n<h4 id=\"缓存穿透\"><a class=\"anchor\" href=\"#缓存穿透\">#</a> 缓存穿透</h4>\n<p>缓存穿透是由于请求一个不存在的数据而导致的</p>\n<ul>\n<li>\n<p>方案一：缓存空结果，对数据库查询不存在的数据依然缓存到缓存中，比如缓存一条空值 unknow, 有效减少查询数据库的效率。优点是实现简单。缺点是缓存了无效数据，占用 Redis 缓存，可能存在缓存与数据库不一致的情况</p>\n</li>\n<li>\n<p>方案二：布隆过滤器。在访问 Redis 之前，先通过布隆过滤器进行筛选。优点是不会缓存无效数据，缺点是实现比较复杂，存在一定的误判.</p>\n<details class=\"info\"><summary>布隆过滤器</summary><div>\n<p>布隆过滤器用于检索一个元素是否在一个集合中。它采用一个很长的二进制数组，通过一些列 hash 函数来确定该数据是否存在.</p>\n<p>具体实现如下</p>\n<p>在向布隆过滤器中添加元素时，会使用多个哈希函数对元素进行 hash, 然后使用数组长度取余，算出一个索引位置，再把数组这几个位置都设置为 1, 这样就完成了元素的添加操作.</p>\n<p>向布隆过滤器查询元素是存在时，和添加元素一样，. 算出数组位置。然后看数组对应位置是否<mark>都</mark>为 1, 只要有一个位置为 0, 代表存在。如果这几个位置都为 1, 代表<mark>可能</mark>存在.</p>\n<p>目前的具体实现由 Guava,Hutool,Redisson</p>\n</div></details>\n</li>\n</ul>\n<h4 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h4>\n<p>高并发情况下，对于热点数据，当数据失效的一瞬间，或者刚开始时缓存中还没有对热点数据进行缓存，所有请求被发送到数据库去查询，导致数据库被压垮.</p>\n<ul>\n<li>方案一：全局锁：在访问数据库之前都请求全局锁，获得的锁的线程才有资格去访问数据库，其他线程必须等待。由于现在的业务都是分布式的，本地锁没法控制其他服务的线程也等待，所以要用全局锁，比如分布式锁.</li>\n<li>方案二：对于热点数据，设置永不过期.\n<ul>\n<li>实现方案一：不设置过期时间，即 &quot;物理&quot; 不过期。优点是简单。缺点是缓存的热点数据是静态的，得不到更新</li>\n<li>实现方案二：逻辑不过期，通过一个异步线程，当检测到超过了过期时间，即更新缓存数据，这样只有前几条是旧数据，后面拿到的即为更新的数据.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h4>\n<p>在某一时刻，大量的 key 或者整个缓存的数据全部过期了或者缓存发生了故障，然后瞬间所有的请求都落到数据库，数据库被压垮</p>\n<p>如何解决？</p>\n<ol>\n<li>Redis 高可用 (搭建 Redis Sentinel 或者 Redis Cluster 集群), 避免 Redis 不可用</li>\n<li>给不同的 key 设置不同的过期时间</li>\n<li>本地缓存 (二级缓存) + 限流 &amp; 降级，避免数据库被压垮</li>\n</ol>\n<hr />\n<p>缓存雪崩与缓存击穿的区别</p>\n<p>缓存击穿某些热点数据 (或者说是同一条数据) 过期了，而走数据库 (即主体为被频繁访问的少量数据)</p>\n<p>缓存雪崩强调的是大量数据 (或者说是所有数据) 都过期了，而走数据库 (即主题为大量数据)</p>\n<p>因此，缓存雪崩核心就是，缓存无法使用，就全部走数据库 \\</p>\n<h2 id=\"redis内存使用完了怎么办\"><a class=\"anchor\" href=\"#redis内存使用完了怎么办\">#</a> Redis 内存使用完了怎么办</h2>\n<p>通过内存配置文件配置最大使用内存</p>\n<p>当达到最大使用内存时使用内存淘汰策略</p>\n<p>默认淘汰策略为 noeviction</p>\n<h2 id=\"redis的string类型的值最大能放多大的数据\"><a class=\"anchor\" href=\"#redis的string类型的值最大能放多大的数据\">#</a> Redis 的 String 类型的值最大能放多大的数据</h2>\n<ul>\n<li>\n<p>string:512MB</p>\n</li>\n<li>\n<p>List:2^32-1 (4,294,967,295) 个元素</p>\n</li>\n<li>\n<p>Set:2^32-1 (4,294,967,295) 个元素</p>\n</li>\n<li>\n<p>Hash: 每个 hash 值最大能放 2^32-1 (4,294,967,295) 个 filed-value 对，Hash 类型仅受部署 Redis 的服务器上的总内存的限制</p>\n</li>\n<li>\n<p>ZSet 与 Set 一样</p>\n</li>\n</ul>\n<h2 id=\"如何保证数据库与redis的数据一致性\"><a class=\"anchor\" href=\"#如何保证数据库与redis的数据一致性\">#</a> 如何保证数据库与 Redis 的数据一致性</h2>\n<p>即数据库发生增删改的时候，数据库的数据要和 Redis 缓存的数据保持一致性</p>\n<h2 id=\"redis集群最大能部署多少个主节点\"><a class=\"anchor\" href=\"#redis集群最大能部署多少个主节点\">#</a> Redis 集群最大能部署多少个主节点</h2>\n<p>16384</p>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--SpringBoot/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--SpringBoot/",
            "title": "八股文概要--SpringBoot",
            "date_published": "2024-04-09T04:22:14.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"springboot自动装配原理\"><a class=\"anchor\" href=\"#springboot自动装配原理\">#</a> SpringBoot 自动装配原理</h2>\n<ol>\n<li>@SpringBootApplication (main 方法上的注解)</li>\n<li>@EnableAutoConfiguration (自动装配核心注解)</li>\n<li>导入 AutoConfigurationImportSelector 组件</li>\n<li>通过 SpringFactoriesLoader 类读取\n<ul>\n<li>META-INF/spring.factories</li>\n<li>org.springframework.boot.autoconfigure.AutoConfiguration.imports</li>\n</ul>\n</li>\n<li>条件注解进行过滤 (只有导入了相关 jar 包才会进行配置)</li>\n<li>ImportSelector 接口</li>\n<li>BeanDefinition</li>\n<li>实例化 Bean 对象，放入 Spring 的 IOC 容器中</li>\n</ol>\n<h2 id=\"如何实现spring-boot-starter\"><a class=\"anchor\" href=\"#如何实现spring-boot-starter\">#</a> 如何实现 Spring Boot Starter</h2>\n<ol>\n<li>写一个 starter 项目，一般是一个空壳，里面不写代码，主要起到 依赖其他项目的作用；</li>\n<li>写一个真正实现自动装配逻辑的项目，在项目 classpath 下写一个 META-INF/spring.factories 文件；</li>\n<li>在 spring.factories 中添加配置:org.springframework.boot.autoconfigure.EnableAutoConfigure = com.kablog.XXXConfiguration</li>\n<li>XXXConfiguration 类需要添加注解 @Configuration;</li>\n<li>上述类一般使用 @Conditional 来适应不同的环境；</li>\n<li>在 XXXConfiguration 类中编写具体代码实现自动化配置，给使用者把该配的配置好，让他人可以直接使用</li>\n</ol>\n<h2 id=\"spring-boot-与-ssm-有什么区别和优势\"><a class=\"anchor\" href=\"#spring-boot-与-ssm-有什么区别和优势\">#</a> Spring Boot 与 SSM 有什么区别和优势</h2>\n<ul>\n<li>SSM10 随版本更新，依赖越来越多，配置越来越多，需要配置大量 xml 文件，开发繁琐</li>\n<li>SpringBoot 约定优于配置，采用自动化配置，自动装配 Bean, 无需 SSM 一样的繁琐配置</li>\n<li>SpringBoot 直接使用 java main 方法运行，可直接内嵌 Tomcat 服务器运行 SpringBoot 程序</li>\n<li>SpingBoot 采用 starter 依赖简化 Maven 配置，自动管理所有 jar 包版本，加入 web starter, 自动引入内嵌的 Tomcat; 当然还提供了大量的 starter</li>\n<li>SpringBoot 可以直接打包成 jar 包运行，部署简单</li>\n</ul>\n<h2 id=\"spring-boot项目如何兼容老的spring项目\"><a class=\"anchor\" href=\"#spring-boot项目如何兼容老的spring项目\">#</a> Spring Boot 项目如何兼容老的 Spring 项目</h2>\n<ul>\n<li>使用 @ImportResource 注解导入旧配置文件</li>\n</ul>\n<h2 id=\"javaconfig\"><a class=\"anchor\" href=\"#javaconfig\">#</a> JavaConfig</h2>\n<ul>\n<li><code>@Configuration</code> : 使用 <code>@Configuration</code>  + 类 替代 xml 文件对 bean 定义</li>\n<li><code>@Bean</code> : 在 @Configuration 中 <code>@Bean</code>  替代  <code>&lt;bean id = &quot;XX&quot; class = &quot;XX&quot;&gt;&lt;/bean&gt;</code></li>\n<li><code>@ComponentScan</code> : 使用 <code>@ComponentScan(basePackage=&quot;XX&quot;)</code> + 类 替代  <code>&lt;context:componentscan basepackage = &quot;XX&quot;&gt;</code> \\</li>\n<li><code>@EnableWebMvc</code> : 使用 <code>EnableWebMvc</code>  替代  <code>&lt;mvc:annotation-driven&gt;</code></li>\n<li><code>@ImportResource</code> : 使用 <code>@ImportResource(locations = &quot;classpath:xxx.xml&quot;)</code> + 类 替代  <code>&lt;import resource = &quot;xxx.xml&quot;&gt;</code></li>\n<li><code>@Properties</code> : 使用 <code>@Properties(&quot;classpath:*.properties&quot;)</code> + 类 替代 <code>&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;&gt;</code></li>\n<li><code>@Value</code> : 使用 <code>@Value(&quot;$&#123;jdbc.xxx&#125;&quot;)</code>  来配置数据源</li>\n</ul>\n<p>使用注解来开发项目</p>\n<h2 id=\"如何排除某些类的自动装配\"><a class=\"anchor\" href=\"#如何排除某些类的自动装配\">#</a> 如何排除某些类的自动装配</h2>\n<p>某些时候配置了如 mybatis-starter 等依赖包，它会自动装配。此时若没有在 properties 中填入相应的 <code>host/port/password/url</code>  等内容，那么运行就会报错。此时应先排除自动装配</p>\n<ul>\n<li>\n<p>在 <code>properties</code>  文件中添加 <code>spring.autoconfigure.exclude = org.xxx.DataSourceAutoConfiguration</code></p>\n</li>\n<li>\n<p>在类上添加注解 <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,xxx.class&#125;)</code></p>\n</li>\n</ul>\n<h2 id=\"如何实现异步调用\"><a class=\"anchor\" href=\"#如何实现异步调用\">#</a> 如何实现异步调用</h2>\n<h3 id=\"是什么\"><a class=\"anchor\" href=\"#是什么\">#</a> 是什么</h3>\n<p>asynchronous call (异步调用): 一个无需等待被调用函数的返回值就能让操作继续进行的方法；</p>\n<h3 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<ul>\n<li>对于一些不需要在主线流程中执行的任务：如注册时发送欢迎短信</li>\n<li>不需要实施等待计算结果的任务：如业务执行记录日志</li>\n<li>为了利用多核 cpu 并发执行的任务：如下单时获取用户住址，用户余额，商品信息</li>\n</ul>\n<h3 id=\"怎么解决\"><a class=\"anchor\" href=\"#怎么解决\">#</a> 怎么解决</h3>\n<p>将这些任务异步执行，即放在另一个线程中去执行，从而避免主线程的阻塞和等待</p>\n<ul>\n<li>方式一:@EnableAsync + @Async + Future + ThreadPoolTaskExecutor</li>\n<li>方式二：CompletableFuture + ThreadPoolTaskExecutor</li>\n</ul>\n<h2 id=\"springboot默认使用什么动态代理\"><a class=\"anchor\" href=\"#springboot默认使用什么动态代理\">#</a> SpringBoot 默认使用什么动态代理</h2>\n<p>默认使用 CGLIB 动态代理而不是 JDK 动态代理</p>\n<p>主要是考虑兼容性</p>\n<p>CGLIB 动态代理可以代理任何类型的目标类，而 JDK 动态代理只能代理实现了接口的目标类，</p>\n<p>因此 CGLIB 覆盖了 JDK 所有使用场景，故为了保证 SpringBoot 中的 AOP 可以面向任何类型的 Bean,</p>\n<p>SpringBoot 默认使用 CGLIB 作为代理的实现方式.</p>\n<h2 id=\"springcloud组件\"><a class=\"anchor\" href=\"#springcloud组件\">#</a> SpringCloud 组件</h2>\n<ul>\n<li>注册中心:<s>Eureka</s>,<mark>Nacos</mark>,Zookeeper,Consul;(服务注册)</li>\n<li>负载均衡：Ribbon,<mark>LoadBalancer</mark>;(客户端的负载均衡)</li>\n<li>服务调用:<s>Feign</s>,<mark>OpenFeign</mark>,Dubbo RPC;(优雅调用远程服务)</li>\n<li>配置中心：Spring Cloud Config,<mark>Nacos</mark>;(统一管理服务配置)</li>\n<li>熔断降级:<s>Hystrix</s>,<mark>Sentinel</mark>;(急骤请求，防止服务雪崩)</li>\n<li>分布式事务:<mark>Seata</mark>;(跨库跨服务的事务管理)</li>\n<li>服务网关:<s>Zuul 1.x</s>,Zuul 2.x,<mark>Spring Cloud Gateway</mark>;(系统入口门面)</li>\n<li>链路跟踪:<mark>Skywalking</mark>,Zipkin;(监控服务状态，协助排查问题)</li>\n</ul>\n<h2 id=\"spring-cloud的理解\"><a class=\"anchor\" href=\"#spring-cloud的理解\">#</a> Spring Cloud 的理解</h2>\n<ol>\n<li>将微服务面临的负载均衡，服务的注册与发现，服务调用，服务路由，服务熔断等技术问题解决方案打包好.</li>\n<li>提供了一整套微服务解决方案，降低开发难度，提供统一标准</li>\n<li>为 Spring 生态注入更强的生命力</li>\n</ol>\n<h2 id=\"服务熔断服务降级\"><a class=\"anchor\" href=\"#服务熔断服务降级\">#</a> 服务熔断？服务降级？</h2>\n<ul>\n<li>\n<p>服务熔断：当服务 A 调用服务 B 时，如果此时服务 B 不可用，那么上游的服务 A 为了保证自己不受影响，就切断调用服务 B, 防止发生服务雪崩，直到 B 服务恢复.(具体指提前做好一种兜底措施，比如返回假的数据，或者记录数据信息到数据库，redis, 文件中，后续进行补救，直到 B 服务恢复)</p>\n</li>\n<li>\n<p>服务降级：当系统负载过高时，对非核心的业务服务进行关闭，来保证核心业务的正常运行；(关闭某些不重要的服务，或者拒绝低优先级应用的服务请求，保证核心应用正常工作)</p>\n</li>\n<li>\n<p>相同：目的相同：保证服务可用性，防止系统整体负载过大甚至崩溃；</p>\n<p>​       表现相同：都是表现出服务暂时不可用的状态</p>\n</li>\n<li>\n<p>不同：服务熔断一般是某个服务 (下游服务) 故障引起，而服务降级一般是从整体负荷考虑.</p>\n</li>\n</ul>\n<h2 id=\"项目重构时为何要对系统进行拆分\"><a class=\"anchor\" href=\"#项目重构时为何要对系统进行拆分\">#</a> 项目重构时为何要对系统进行拆分</h2>\n<h2 id=\"eureka和nacos区别\"><a class=\"anchor\" href=\"#eureka和nacos区别\">#</a> Eureka 和 Nacos 区别</h2>\n<ul>\n<li>\n<p>相同：1. 都用于服务的注册与发现 2. 都支持服务的心跳健康检查 3. 都支持高可用</p>\n</li>\n<li>\n<p>不同:</p>\n<table>\n<thead>\n<tr>\n<th>Nacos</th>\n<th>Eureka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>支持主动对微服务状态检测，临时实例心跳检测，永久实例主动检测</td>\n<td></td>\n</tr>\n<tr>\n<td>临时实例不正常会从注册中心删除，永久实例不会删除</td>\n<td></td>\n</tr>\n<tr>\n<td>支持服务列表变更时的主动消息推送，服务列表更新会更及时</td>\n<td></td>\n</tr>\n<tr>\n<td>集群支持两种模式，默认 AP, 存在非临时实例时采用 CP 模式</td>\n<td>只支持 AP</td>\n</tr>\n<tr>\n<td>支持注册中心，配置中心</td>\n<td>只支持注册中心</td>\n</tr>\n<tr>\n<td>具备较好上下线流量管理界面</td>\n<td>后台界面仅供展示，需使用 API 操作上下线，无流量管理</td>\n</tr>\n<tr>\n<td>社区活跃</td>\n<td>闭源</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n<h2 id=\"acidbase理论cap理论的关系\"><a class=\"anchor\" href=\"#acidbase理论cap理论的关系\">#</a> ACID,BASE 理论，CAP 理论的关系</h2>\n<h3 id=\"acid\"><a class=\"anchor\" href=\"#acid\">#</a> ACID</h3>\n<p>ACID 是传统数据库中常用的设计理念</p>\n<ol>\n<li>Atomicity (原子性)</li>\n<li>Consistency (一致性)</li>\n<li>Isolation (隔离性)</li>\n<li>Durability (持久性)</li>\n</ol>\n<p>ACID 它追求的是数据的强一致性模型</p>\n<h3 id=\"base理论\"><a class=\"anchor\" href=\"#base理论\">#</a> BASE 理论</h3>\n<p>BASE 理论支持的是大型分布式系统；</p>\n<ol>\n<li>基本可用 (Basically Available): 分布式系统出现不可预知故障时，允许损失部分可用性</li>\n<li>软状态 (Soft State): 允许系统中的数据存在中间状态，允许系统在不同节点的数据副本之间同步存在延时</li>\n<li>最终一致性 (Eventually Consistent): 所有数据副本在一段时间同步后最终一致的状态，无需实时保证系统数据强一致</li>\n</ol>\n<p>BASE 理论是通过牺牲强一致性以获得高可用性</p>\n<h3 id=\"cap理论\"><a class=\"anchor\" href=\"#cap理论\">#</a> CAP 理论</h3>\n<p>CAP 理论是支持分布式系统而提出的；</p>\n<ol>\n<li>C: 一致性 (Consistency)</li>\n<li>A: 可用性 (Availability)</li>\n<li>P: 分区容错性 (Tolerance of network Partition)</li>\n</ol>\n<p>分布式系统无法做到 CAP, 只能做到其中两项，要么 CP, 要么 AP</p>\n<h3 id=\"三者关系\"><a class=\"anchor\" href=\"#三者关系\">#</a> 三者关系</h3>\n<p>ACID 和 CAP,BASE 代表了两种截然相反的设计哲学；</p>\n<p>在分布式系统设计中，根据不同场景的实际情况，可以把 ACID,CAP,BASE 结合起来使用</p>\n<h3 id=\"注册中心选择cp还是ap\"><a class=\"anchor\" href=\"#注册中心选择cp还是ap\">#</a> 注册中心选择 CP 还是 AP</h3>\n<p>简单来说，应该优先选择 AP (可用性) 然后保证最终一致性即可，而选择 CP (一致性) 的话，随着应用规模增大，应用实例频繁注册或删除，必将影响注册中心服务注册与发现的效率.</p>\n<h2 id=\"接口幂等性\"><a class=\"anchor\" href=\"#接口幂等性\">#</a> 接口幂等性</h2>\n<p>幂等性 = 多次执行无副作用</p>\n<p>考虑幂等性即考虑多次执行，多次请求的情况</p>\n<p>在以下场景可能会使用到</p>\n<ul>\n<li>因网络波动引起的重复请求</li>\n<li>用户重复操作 (无意触发或因无响应而有意触发等)</li>\n<li>应用使用了失败或超时重试机制 (如 RPC 重试，业务层重试等)</li>\n<li>第三方平台的接口 (如：支付成功回调接口), 因为异常导致多次回调</li>\n<li>中间件 / 应用服务根据自身特性，也有可能进行重试</li>\n<li>用户双击提交按钮</li>\n<li>用户页面重复刷新</li>\n<li>使用浏览器后退按钮重复之前的操作，导致重复提交表单</li>\n<li>使用浏览器历史记录重复提交表单</li>\n<li>浏览器重复的 http 请求</li>\n<li>定时任务重复执行</li>\n</ul>\n<p>一般在数据访问层进行幂等性的设计</p>\n<p>使用唯一索引防止幂等性问题：简单粗暴，当数据重复时会抛出异常，保证不会出现脏数据</p>\n<p>使用 Token+Redis 的幂等方案 (申请 token 阶段和业务操作阶段): 先获得 token 存入 redis, 根据 token 执行处理，然后删除 token. 重复请求时，由于缓存中没有 token, 表示非法请求</p>\n<h2 id=\"分布式事务\"><a class=\"anchor\" href=\"#分布式事务\">#</a> 分布式事务</h2>\n<p>事务通常用于数据库领域</p>\n<p>事务是指对数据库进行读或写的一组操作，要么都执行，要么都不执行，不允许只执行一部分的情况；</p>\n<p>由 insert,delete,update,select 组成的一组操作，要么都 commit, 要么都 rollback</p>\n<p>本地事务：仅支持单库事务，保证 ACID</p>\n<p>分布式事务：多个库，因此有多个数据源的连接，不能使用 spring 的事务管理</p>\n<p>分布式事务解决方案</p>\n<ul>\n<li>2PC</li>\n<li>3PC</li>\n<li>TCC</li>\n<li>本地消息异步确认</li>\n<li>可靠消息最终一致性</li>\n<li>最大努力通知</li>\n<li>RocketMQ 解决分布式事务</li>\n<li>阿里巴巴的 Seata 解决分布式事务</li>\n</ul>\n<p>如何进行服务的限流</p>\n<ul>\n<li>计数器法</li>\n<li>漏桶算法</li>\n<li>令牌桶算法 (Guava 框架)</li>\n</ul>\n<p>分布式环境如何进行服务的限流</p>\n<ul>\n<li>Nginx 限流</li>\n<li>OpenResty 限流</li>\n<li>Sentinel 限流</li>\n<li>Redis + Lua 限流</li>\n<li>Spring Cloud Gateway 限流</li>\n</ul>\n<h2 id=\"spring常用注解\"><a class=\"anchor\" href=\"#spring常用注解\">#</a> Spring 常用注解</h2>\n<ul>\n<li><code>@Component</code> ：泛指组件，当不确定一个 Bean 属于哪个层（如 Controller、Service 或 Repository）时使用。</li>\n<li><code>@Controller</code> ：用于标记控制层的组件。</li>\n<li><code>@Service</code> ：用于标记服务层的组件。</li>\n<li><code>@Repository</code> ：用于标记数据访问层的组件。</li>\n<li><code>@Autowired</code> ：自动注入依赖。</li>\n<li><code>@RequestMapping</code> ：用于映射 HTTP 请求到处理器的方法。</li>\n<li><code>@ResponseBody</code> ：表示该方法的返回结果直接写入 HTTP 响应正文中。</li>\n<li><code>@PathVariable</code> ：用于将请求 URL 中的模板变量映射到功能处理方法的参数上。</li>\n<li><code>@RestController</code> ：是 <code>@Controller</code>  和 <code>@ResponseBody</code>  的结合体，用于创建 RESTful 控制器。</li>\n<li><code>@Transactional</code> ：声明事务管理。</li>\n</ul>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--mysql/",
            "url": "https://kagurazakaasahi.github.io/%E5%85%AB%E8%82%A1%E6%96%87%E6%A6%82%E8%A6%81--mysql/",
            "title": "八股文概要--Mysql",
            "date_published": "2024-04-08T14:50:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> MYSQL</h2>\n<ul>\n<li>关系型数据库</li>\n<li>默认引擎 InnoDB, 通过 JDBC 连接</li>\n<li>支持事务，分布式事务，savepoint</li>\n<li>undo,redo,binlog</li>\n</ul>\n<h3 id=\"数据库优化方式\"><a class=\"anchor\" href=\"#数据库优化方式\">#</a> 数据库优化方式</h3>\n<ul>\n<li>服务器硬件:cpu, 内存，磁盘 io, 网卡流量</li>\n<li>服务器操作系统配置</li>\n<li>存储引擎选择</li>\n<li>数据库自身配置参数</li>\n<li>数据库表结构的设计和 SQL 语句的执行效率 (慢查询，不合理的数据库表结构设计，不合理索引)</li>\n<li>数据库架构：高并发下读写分离，分库分表，多级缓存，搜索引擎</li>\n</ul>\n<h4 id=\"如何定位慢查询\"><a class=\"anchor\" href=\"#如何定位慢查询\">#</a> 如何定位慢查询</h4>\n<ul>\n<li>业务驱动</li>\n<li>测试驱动</li>\n<li>系统跟踪驱动 (Prometheus,SkyWalking)</li>\n<li>慢查询日志</li>\n</ul>\n<h3 id=\"索引\"><a class=\"anchor\" href=\"#索引\">#</a> 索引</h3>\n<ul>\n<li>一种数据结构，方便快速的查找数据，类似于书的目录</li>\n<li>底层数据结构为 B + 树 (多),hash 树</li>\n<li>类型分为，普通索引，唯一索引，fullText 索引，spatial 索引</li>\n<li>添加索引的方式</li>\n<li>索引的命名规范</li>\n<li>什么是索引下推，有什么作用 (减少回表次数)</li>\n<li>局部性原理与磁盘预读</li>\n<li>为什么使用自增数字作为组件索引 (依次往后写入，减少移动，减小开销)</li>\n<li>主键索引；辅助索引 (二级索引); 聚集索引 (聚簇索引); 非聚集索引 (非聚簇索引)</li>\n<li>什么是覆盖索引 (一种 sql 优化手段)</li>\n</ul>\n",
            "tags": [
                "学习",
                "JAVA八股文"
            ]
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.25/",
            "url": "https://kagurazakaasahi.github.io/3.25/",
            "title": "3.25",
            "date_published": "2024-03-25T14:39:01.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"题1\"><a class=\"anchor\" href=\"#题1\">#</a> 题 1</h2>\n<pre><code>54. 螺旋矩阵\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n示例 2：\n\n\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n \n\n提示：\n\nm == matrix.length\nn == matrix[i].length\n1 &lt;= m, n &lt;= 10\n-100 &lt;= matrix[i][j] &lt;= 100\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<pre><code class=\"language-C\">int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &#123;\n    *returnSize = matrixSize * (*matrixColSize);\n    int* arr = (int*)malloc(*returnSize * sizeof(int));\n    int num = 0;\n    int UP = 0;\n    int DOWN = matrixSize - 1;\n    int LEFT = 0;\n    int RIGHT = *matrixColSize - 1;\n\n    while (LEFT &lt;= RIGHT &amp;&amp; UP &lt;= DOWN) &#123;\n        for (int i = LEFT; i &lt;= RIGHT &amp;&amp; num &lt; *returnSize; i++) &#123;\n            arr[num++] = matrix[UP][i];\n        &#125;\n        UP++;\n        for (int i = UP; i &lt;= DOWN &amp;&amp; num &lt; *returnSize; i++) &#123;\n            arr[num++] = matrix[i][RIGHT];\n        &#125;\n        RIGHT--;\n        for (int i = RIGHT; i &gt;= LEFT &amp;&amp; num &lt; *returnSize; i--) &#123;\n            arr[num++] = matrix[DOWN][i];\n        &#125;\n        DOWN--;\n        for (int i = DOWN; i &gt;= UP &amp;&amp; num &lt; *returnSize; i--) &#123;\n            arr[num++] = matrix[i][LEFT];\n        &#125;\n        LEFT++;\n    &#125;\n    return arr;\n&#125;\n//通过设置最上,最下,最左,最右作为边界条件,按照左下右上的顺序,输出到返回数组中,并修改边界,通过判定边界是否重合来决定何时停止循环\n</code></pre>\n</div></details>\n",
            "tags": []
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.24/",
            "url": "https://kagurazakaasahi.github.io/3.24/",
            "title": "3.24",
            "date_published": "2024-03-24T14:44:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><pre><code>73. 矩阵置零\n\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n示例 2：\n\n\n输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n \n\n提示：\n\nm == matrix.length\nn == matrix[0].length\n1 &lt;= m, n &lt;= 200\n-231 &lt;= matrix[i][j] &lt;= 231 - 1\n \n\n进阶：\n\n一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n你能想出一个仅使用常量空间的解决方案吗？\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<pre><code class=\"language-C\">void setZeroes(int** matrix, int matrixSize, int* matrixColSize) &#123;\n    int col0 = 1, rows = matrixSize, cols = *matrixColSize;\n    \n    // 使用第一行和第一列来标记0的位置,col0为(0,0)点\n    for (int i = 0; i &lt; rows; i++) &#123;\n        if (matrix[i][0] == 0) col0 = 0;\n        for (int j = 1; j &lt; cols; j++)\n            if (matrix[i][j] == 0)\n                matrix[i][0] = matrix[0][j] = 0;\n    &#125;\n    \n    // 逆序填充0，以防止第一行和第一列的标记被提前清除\n    for (int i = rows - 1; i &gt;= 0; i--) &#123;\n        for (int j = cols - 1; j &gt;= 1; j--)\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        if (col0 == 0) matrix[i][0] = 0;\n    &#125;\n&#125;\n</code></pre>\n</div></details>\n",
            "tags": []
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.18/",
            "url": "https://kagurazakaasahi.github.io/3.18/",
            "title": "3.18",
            "date_published": "2024-03-18T06:32:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><pre><code>3. 无重复字符的最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长\n子串的长度。\n\n \n\n示例 1:\n\n输入: s = &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n示例 2:\n\n输入: s = &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n示例 3:\n\n输入: s = &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n \n\n提示：\n\n0 &lt;= s.length &lt;= 5 * 104\ns 由英文字母、数字、符号和空格组成\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<p>使用滑动窗口法即可解决，关键在于如何确定如何修改窗口边界</p>\n<p>具体代码如下:</p>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint max(int a,int b)&#123;\n    return a&gt;b?a:b;\n&#125;\n\nint lengthOfLongestSubstring(char* s) &#123;\n int char_index[128];\n    memset(char_index, -1, sizeof(char_index)); // 初始化为 -1\n    // 初始化滑动窗口的左边界\n    int left = 0;\n    // 初始化最长子串的长度\n    int max_length = 0;\t\n    \n    for (int right = 0; s[right] != '\\0'; right++) &#123;\n        // 如果字符已经在数组中，并且它的索引大于等于左边界，更新左边界\n        if (char_index[s[right]] &gt;= left) &#123;\n            left = char_index[s[right]] + 1;\n        &#125;\n        // 更新字符的索引\n        char_index[s[right]] = right;\n        // 更新最长子串的长度\n        max_length = (right - left + 1) &gt; max_length ? (right - left + 1) : max_length;\n    &#125;\n\n    return max_length;\n&#125;\n</code></pre>\n<pre><code>这段代码实现了求解给定字符串 s 中不含重复字符的最长子串的长度。让我详细解释一下它的思路：\n\n滑动窗口：这个算法使用了滑动窗口的思想。滑动窗口是一个固定大小的窗口，可以在字符串上滑动，以便处理连续的子串。\n字符索引数组：代码中定义了一个名为 char_index 的整数数组，用于存储每个字符在字符串中的最新索引位置。初始时，所有元素都被设置为 -1。\n左指针和右指针：我们使用两个指针 left 和 right 来构建滑动窗口。初始时，left 和 right 都指向字符串的开头。\n遍历字符串：我们遍历字符串 s，从左到右，处理每个字符。\n更新左指针：\n如果字符 s[right] 已经在 char_index 数组中，并且它的索引大于等于 left，说明窗口内有重复字符。\n此时，我们将 left 更新为 char_index[s[right]] + 1，即将左指针移动到重复字符的下一个位置，以消除重复。\n更新字符索引：将 char_index[s[right]] 更新为 right，表示字符 s[right] 最新出现的位置。\n更新最长子串长度：计算当前窗口的长度 (right - left + 1)，并将其与 max_length 比较，取较大值作为最长子串的长度。\n右指针右移：将右指针 right 向右移动一位，继续处理下一个字符。\n返回最长子串长度：最终返回 max_length，即不含重复字符的最长子串的长度。\n这样，代码通过维护一个滑动窗口和字符索引数组，有效地找到了不含重复字符的最长子串的长度。\n\n该代码值得学习的是用s[right]是否等于'\\0'来判断是否到了数组末尾,避免了使用strlen计算数组的长度,然后使用?:来比较大小,省去了写max函数\n</code></pre>\n</div></details>\n<pre><code>30. 串联所有单词的子串\n\n给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]， 那么 &quot;abcdef&quot;， &quot;abefcd&quot;，&quot;cdabef&quot;， &quot;cdefab&quot;，&quot;efabcd&quot;， 和 &quot;efcdab&quot; 都是串联子串。 &quot;acdbef&quot; 不是串联子串，因为他不是任何 words 排列的连接。\n返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n\n \n\n示例 1：\n\n输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]\n输出：[0,9]\n解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n示例 2：\n\n输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n输出：[]\n解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n示例 3：\n\n输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]\n输出：[6,9,12]\n解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。\n子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。\n \n\n提示：\n\n1 &lt;= s.length &lt;= 104\n1 &lt;= words.length &lt;= 5000\n1 &lt;= words[i].length &lt;= 30\nwords[i] 和 s 由小写英文字母组成\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// 函数功能：在字符串 s 中查找所有可以由 words 数组中的单词串联形成的子串的起始位置\n// 参数说明：\n//   s: 输入的字符串\n//   words: 字符串数组，存储要匹配的单词\n//   wordsSize: words 数组中单词的数量\n//   returnSize: 输出参数，存储结果数组的大小\n// 返回值：指向存储结果的整数数组的指针\nint* findSubstring(char * s, char ** words, int wordsSize, int* returnSize) &#123;\n    *returnSize = 0;\n    if (wordsSize == 0) return NULL;\n\n    int one_word_len = strlen(words[0]);\n    int word_num = wordsSize;\n    int all_len = one_word_len * word_num;\n    int s_len = strlen(s);\n\n    if (s_len &lt; all_len) return NULL;\n\n    char temp[one_word_len + 1]; // 临时存储截取的子串\n    int *local = (int *)malloc(sizeof(int) * s_len); // 存储结果的整数数组\n    int flag[wordsSize]; // 标记单词是否被查到\n    int i = 0, j, res, k;\n\n    while (i + all_len &lt;= s_len) &#123;\n        for (int m = 0; m &lt; wordsSize; m++) flag[m] = 0;\n\n        // 通过滑动窗口的方式截取长度为 wordLen * wordsCount 的子串\n        for (j = i; j &lt; i + all_len; j += one_word_len) &#123;\n            strncpy(temp, s + j, one_word_len);\n            temp[one_word_len] = '\\0'; // 注意：将字符数组末尾设置为 '\\0'\n\n            res = 0; // 标记该单词在 words 中是否被查到\n            for (k = 0; k &lt; wordsSize; k++) &#123;\n                if (flag[k] == 1) continue;\n                if (strcmp(temp, words[k]) == 0) &#123;\n                    flag[k] = 1;\n                    res = 1;\n                    break;//找到了\n                &#125;\n            &#125;\n-.3\n    31\n            if (res == 0) break;//没找到\n        &#125;\n\n        if (res == 1) &#123;\n            local[(*returnSize)++] = i; // 将子串的起始索引保存到结果数组中\n        &#125;\n\n        i++;\n    &#125;\n\n    return local;\n&#125;\n\nint main() &#123;\n    char s[] = &quot;barfoothefoobarman&quot;;\n    char *words[] = &#123;&quot;foo&quot;, &quot;bar&quot;&#125;;\n    int wordsSize = 2;\n    int returnSize;\n    int *result = findSubstring(s, words, wordsSize, &amp;returnSize);\n\n    printf(&quot;Result: &quot;);\n    for (int i = 0; i &lt; returnSize; i++) &#123;\n        printf(&quot;%d &quot;, result[i]);\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n</div></details>\n",
            "tags": []
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.16/",
            "url": "https://kagurazakaasahi.github.io/3.16/",
            "title": "3.16",
            "date_published": "2024-03-16T05:14:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><pre><code>392. 判断子序列\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。\n\n进阶：\n\n如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n致谢：\n\n特别感谢 @pbrother 添加此问题并且创建所有测试用例。\n\n \n\n示例 1：\n\n输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;\n输出：true\n示例 2：\n\n输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;\n输出：false\n \n\n提示：\n\n0 &lt;= s.length &lt;= 100\n0 &lt;= t.length &lt;= 10^4\n两个字符串都只由小写字符组成。\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<p>很简单，每个字符串各一个指针不断向后移动比较即可</p>\n<pre><code class=\"language-C\">bool isSubsequence(char* s, char* t) &#123;\n    int slen = strlen(s),tlen = strlen(t);\n    int si = 0,ti = 0;\n    while(si&lt;slen &amp;&amp; ti&lt;tlen)&#123;\n        while(ti&lt;=tlen &amp;&amp; s[si] != t[ti])&#123;\n            ti++;\n        &#125;\n        if(ti&lt;tlen)&#123;\n            si++;\n            ti++;\n        &#125;\n    &#125;\n    if(si == slen)&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p>但以上代码过于复杂，其实可以直接移动 s,t 的指针最后判断 s 的指针指向的是否为 '/0' 即可</p>\n<p>优化后代码如下:</p>\n<pre><code class=\"language-C\">bool isSubsequence(char* s, char* t) &#123;\n    while (*s &amp;&amp; *t) &#123;\n        if (*s == *t) &#123;\n            s++; // 字符相等，s后移\n        &#125;\n        t++; // 每次比较t均后移\n    &#125;\n    return (*s == '\\0'); // 字符串s仅存有结束符，说明s是t的子序列\n&#125;\n</code></pre>\n<p>很明显的简化了代码</p>\n</div></details>\n<pre><code>209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其总和大于等于 target 的长度最小的 连续\n子数组\n [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n \n\n示例 1：\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例 2：\n\n输入：target = 4, nums = [1,4,4]\n输出：1\n示例 3：\n\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n \n\n提示：\n\n1 &lt;= target &lt;= 109\n1 &lt;= nums.length &lt;= 105\n1 &lt;= nums[i] &lt;= 105\n \n\n进阶：\n\n如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<pre><code class=\"language-C\">int min(int a,int b)&#123;\n    return a&lt;b?a:b;\n&#125;\n\nint minSubArrayLen(int target, int* nums, int numsSize) &#123;\n    int left = 0,right = 0;\n    int sum = 0;\n    int minlen = numsSize + 1;\n    while(right &lt; numsSize)&#123;\n        sum += nums[right++];\n        while(sum &gt;= target)&#123;\n            minlen = min(minlen,right-left);\n            sum -= nums[left++];\n        &#125;\n    &#125;\n    return minlen&gt;numsSize?0:minlen; \n&#125;\n//滑动窗口\n</code></pre>\n<p>滑动窗口先增加窗口的 right, 满足条件后增加 left 缩小窗口直至不满足条件，如此只需遍历一次 (将窗口从左滑到右) 即可遍历所有可能情况，时间复杂度为 O (n);</p>\n<p>当然滑动窗口法是该题比较优秀的算法，考虑到通用性，这里还有一种时间复杂度为 O (nlogn) 的算法，具体思路为创建一个前缀和数组 O (n)，然后通过二分查找 (logn) 确定每个前缀和的满足最小条件的另一个前缀和，从中取得最小值即为结果，总时间复杂度即为 O (nlogn). 当然该算法除时间会随数据规模的增大而增大，还需额外的空间及二分的计算，增加了计算与内存的使用，因此不推荐使用。</p>\n</div></details>\n",
            "tags": []
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.14/",
            "url": "https://kagurazakaasahi.github.io/3.14/",
            "title": "3.14",
            "date_published": "2024-03-14T07:22:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><pre><code>58. 最后一个单词的长度\n给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大\n子字符串\n。\n\n \n\n示例 1：\n\n输入：s = &quot;Hello World&quot;\n输出：5\n解释：最后一个单词是“World”，长度为5。\n示例 2：\n\n输入：s = &quot;   fly me   to   the moon  &quot;\n输出：4\n解释：最后一个单词是“moon”，长度为4。\n示例 3：\n\n输入：s = &quot;luffy is still joyboy&quot;\n输出：6\n解释：最后一个单词是长度为6的“joyboy”。\n \n\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 仅有英文字母和空格 ' ' 组成\ns 中至少存在一个单词\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">lengthOfLastWord</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> now <span class=\"token operator\">=</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"now = %d num = %d s[0] = %c\"</span><span class=\"token punctuation\">,</span>now<span class=\"token punctuation\">,</span>num<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>now <span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token char\">' '</span> <span class=\"token operator\">||</span> num <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\nwhile\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token char\">' '</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        now<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\nnum = %d now = %d\"</span><span class=\"token punctuation\">,</span>num<span class=\"token punctuation\">,</span>now<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num = %d\"</span><span class=\"token punctuation\">,</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>从后往前遍历直到第一个空格停止计数即可，注意考虑后面一段全为空格的情况 (忽略计数), 以及 now&lt;0 会导致数组越界，此时根据与或特性，将 &quot;now &gt;= 0&quot; 的条件写在前面即可避免</p>\n</div></details>\n<pre><code>14. 最长公共前缀\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n\n \n\n示例 1：\n\n输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n输出：&quot;fl&quot;\n示例 2：\n\n输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n输出：&quot;&quot;\n解释：输入不存在公共前缀。\n \n\n提示：\n\n1 &lt;= strs.length &lt;= 200\n0 &lt;= strs[i].length &lt;= 200\nstrs[i] 仅由小写英文字母组成\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<pre><code class=\"language-C\">char* longestCommonPrefix(char** strs, int strsSize) &#123;\n    // 如果字符串数组为空，直接返回空字符串\n    if (strsSize == 0) &#123;\n        return &quot;&quot;;\n    &#125;\n    \n    // 计算第一个字符串的长度\n    int len = strlen(strs[0]);\n    \n    // 遍历第一个字符串的每个字符\n    for (int i = 0; i &lt; len; i++) &#123;\n        // 逐个与其他字符串的相同位置字符比较\n        for (int j = 1; j &lt; strsSize; j++) &#123;\n            if (strs[j][i] != strs[0][i]) &#123;\n                // 如果不匹配，截取前缀并返回\n                char* dest = (char*)malloc(i + 1);\n                strncpy(dest, strs[0], i);\n                dest[i] = '\\0'; // 添加字符串结束符\n                return dest;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 如果所有字符串都匹配，返回第一个字符串\n    return strs[0];\n&#125;\n</code></pre>\n<p>上述方法为纵向比较，值得注意的是首先进行判空防止无意义的计算，以及在循环函数外将字符串长度计算出来。最后就是复制字符串的方法</p>\n<p>以下还有另一种方法 -- 横向比较法</p>\n<p>将每个字符串与第一个字符串相比较，若不同就将此位置改为 &quot;\\0&quot;, 这样输出的字符串遇到第一个 &quot;\\0&quot; 就停止，即为最短公共字符串了，具体代码如下:</p>\n<pre><code class=\"language-C\">char* longestCommonPrefix(char** strs, int strsSize) &#123;\n    // 如果字符串数组为空，直接返回空字符串\n    if (strsSize == 0) &#123;\n        return &quot;&quot;;\n    &#125;\n    \n    // 将第一个字符串作为模板\n    char* prefix = strs[0];\n    \n    // 遍历其他字符串\n    for (int i = 1; i &lt; strsSize; i++) &#123;\n        // 逐个字符比较\n        int j = 0;\n        while (prefix[j] &amp;&amp; strs[i][j] &amp;&amp; prefix[j] == strs[i][j]) &#123;\n            j++;\n        &#125;\n        // 截取前缀\n        prefix[j] = '\\0';\n    &#125;\n    \n    return prefix;\n&#125;\n</code></pre>\n<pre><code>当比较纵向比较和横向比较这两种方法时，我们可以考虑它们的优势和局限性。\n\n纵向比较：\n优势：\n简单直接：从第一个字符串开始，逐个字符地与其他字符串的相同位置的字符进行比较。\n代码清晰：不需要额外的循环变量，代码结构清晰易懂。\n适用性广泛：适用于不同长度的字符串数组。\n局限性：\n效率较低：如果第一个字符串很长，需要逐个字符地与其他字符串比较，可能会导致不必要的计算。\n不适用于空数组：如果输入的字符串数组为空，需要额外处理。\n横向比较：\n优势：\n效率较高：将第一个字符串作为模板，逐个字符地与其他字符串的相同位置的字符进行比较，避免了多次计算字符串长度。\n一次遍历：只需要一次遍历其他字符串，而不是逐个字符地比较。\n局限性：\n需要额外的循环变量：需要一个循环变量来遍历其他字符串。\n不适用于不同长度的字符串数组：如果其他字符串的长度不一致，需要额外处理。\n</code></pre>\n</div></details>\n",
            "tags": []
        },
        {
            "id": "https://kagurazakaasahi.github.io/3.13/",
            "url": "https://kagurazakaasahi.github.io/3.13/",
            "title": "3.13",
            "date_published": "2024-03-13T13:58:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><pre><code>42. 接雨水\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n示例 1：\n\n\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n示例 2：\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n \n\n提示：\n\nn == height.length\n1 &lt;= n &lt;= 2 * 104\n0 &lt;= height[i] &lt;= 105\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<p>分析题目易知只需知道每一格左右两侧最大高度即可求出当前格所接雨水，问题就转化为求每一格左右两侧最大高度，暴力算时间复杂度 O (n^2). 如果使用一段空间保存每一格的左右两侧最高值，即可将时间复杂度优化为 O (n) 空间复杂度为 O (n). 再进一步，使用双指针法动态维护每一格左右两侧的最高值，即可将空间复杂度优化为 O (1).</p>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n\nint trap(int* height, int heightSize) &#123;\n    int left = 0, right = heightSize - 1;\n    int l_max = 0, r_max = 0;\n    int ans = 0;\n\n    while (left &lt;= right) &#123;\n        // 更新左侧最高柱子高度\n        l_max = (height[left] &gt; l_max) ? height[left] : l_max;\n        // 更新右侧最高柱子高度\n        r_max = (height[right] &gt; r_max) ? height[right] : r_max;\n\n        // 计算当前柱子上方可以接住的雨水量\n        if (l_max &lt; r_max) &#123;\n            ans += l_max - height[left];\n            left++;\n        &#125; else &#123;\n            ans += r_max - height[right];\n            right--;\n        &#125;\n    &#125;\n\n    return ans;\n&#125;\n\nint main() &#123;\n    int height[] = &#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;;\n    int heightSize = sizeof(height) / sizeof(height[0]);\n\n    int result = trap(height, heightSize);\n    printf(&quot;可以接住的雨水量：%d\\n&quot;, result);\n\n    return 0;\n&#125;\n</code></pre>\n</div></details>\n<pre><code>13. 罗马数字转整数\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。\n\n \n\n示例 1:\n\n输入: s = &quot;III&quot;\n输出: 3\n示例 2:\n\n输入: s = &quot;IV&quot;\n输出: 4\n示例 3:\n\n输入: s = &quot;IX&quot;\n输出: 9\n示例 4:\n\n输入: s = &quot;LVIII&quot;\n输出: 58\n解释: L = 50, V= 5, III = 3.\n示例 5:\n\n输入: s = &quot;MCMXCIV&quot;\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n \n\n提示：\n\n1 &lt;= s.length &lt;= 15\ns 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')\n题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\nIL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。\n</code></pre>\n<details class=\"info\"><summary>题解</summary><div>\n<p>分析易知只需将字符映射为数字再按照罗马字符规则计算即可得到答案</p>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n\nint romanToInt(char * s)&#123;\n    int nums[128];\n    nums['I'] = 1;\n    nums['V'] = 5;\n    nums['X'] = 10;\n    nums['L'] = 50;\n    nums['C'] = 100;\n    nums['D'] = 500;\n    nums['M'] = 1000;\n    \n    int sum = 0;\n    while(*s)&#123;\n        if(nums[*s] &lt; nums[*(s+1)]) sum -= nums[*s];\n        else sum += nums[*s];\n        s++;\n    &#125;//计算规则\n    return sum;\n&#125;\n\nint main() &#123;\n    char s[] = &quot;MCMXCIV&quot;;\n    printf(&quot;%d\\n&quot;, romanToInt(s));\n    return 0;\n&#125;\n</code></pre>\n</div></details>\n",
            "tags": []
        }
    ]
}